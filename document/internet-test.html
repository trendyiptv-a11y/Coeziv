<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Test parametri Internet (HTML)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background:#0b1020; color:#e9ecf1; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 24px; }
    h1 { margin: 0 0 12px; font-size: 22px; }
    .card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 16px; padding: 16px; }
    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 12px; margin-top: 12px; }
    .col6 { grid-column: span 6; }
    .col12 { grid-column: span 12; }
    @media (max-width: 860px){ .col6 { grid-column: span 12; } }
    button {
      appearance: none; border: 0; cursor: pointer;
      background:#4c7dff; color:white; font-weight: 600;
      padding: 10px 14px; border-radius: 12px;
    }
    button:disabled{ opacity: .55; cursor: not-allowed; }
    .row { display:flex; gap: 10px; flex-wrap: wrap; align-items:center; }
    .kpi { display:flex; gap: 10px; align-items: baseline; }
    .kpi .label { opacity:.8; font-size: 13px; }
    .kpi .value { font-size: 22px; font-weight: 700; }
    .muted { opacity:.75; }
    .log { background: rgba(0,0,0,0.25); border:1px solid rgba(255,255,255,0.10); border-radius: 12px; padding: 12px; height: 220px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    .bar { height: 10px; border-radius: 999px; background: rgba(255,255,255,0.10); overflow:hidden; }
    .bar > div { height:100%; width: 0%; background: #7ee787; transition: width .2s; }
    .pill { padding: 4px 10px; border-radius: 999px; background: rgba(255,255,255,0.10); border: 1px solid rgba(255,255,255,0.12); font-size: 12px;}
    input, select {
      background: rgba(255,255,255,0.08); color:#e9ecf1;
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 10px; padding: 8px 10px;
    }
    a { color:#9bb6ff; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Test parametri Internet (HTML + JS)</h1>
    <div class="card">
      <div class="row">
        <button id="btnStart">Pornește testul</button>
        <button id="btnStop" disabled>Oprește</button>
        <span class="pill" id="status">Idle</span>
        <span class="muted">Rulează direct în browser. Pentru rezultate bune, închide download-uri / streaming.</span>
      </div>

      <div class="grid">
        <div class="card col6">
          <div class="kpi"><span class="label">Ping (ms)</span><span class="value" id="ping">—</span></div>
          <div class="kpi"><span class="label">Jitter (ms)</span><span class="value" id="jitter">—</span></div>
          <div class="kpi"><span class="label">Pierderi (%)</span><span class="value" id="loss">—</span></div>
          <div class="muted">Ping-ul este aproximat prin request-uri HTTPS (nu ICMP).</div>
        </div>

        <div class="card col6">
          <div class="kpi"><span class="label">Download (Mbps)</span><span class="value" id="down">—</span></div>
          <div class="bar" title="Progres download"><div id="downBar"></div></div>
          <div style="height:10px"></div>
          <div class="kpi"><span class="label">Upload (Mbps)</span><span class="value" id="up">—</span></div>
          <div class="bar" title="Progres upload"><div id="upBar"></div></div>
          <div class="muted">Vitezele depind de serverele de test și de cache; folosim anti-cache.</div>
        </div>

        <div class="card col12">
          <div class="row" style="justify-content: space-between;">
            <div class="row">
              <label class="muted">Nr. probe ping:</label>
              <input id="pingSamples" type="number" min="5" max="50" value="12" style="width:90px">
              <label class="muted">Timeout (ms):</label>
              <input id="timeoutMs" type="number" min="800" max="10000" value="2500" style="width:110px">
              <label class="muted">Dimensiune upload (MB):</label>
              <select id="uploadMB">
                <option value="2">2</option>
                <option value="5" selected>5</option>
                <option value="10">10</option>
              </select>
              <label class="muted">Fișier download (MB):</label>
              <select id="downloadMB">
                <option value="10">10</option>
                <option value="25" selected>25</option>
                <option value="50">50</option>
                <option value="100">100</option>
              </select>
            </div>
            <div class="row">
              <button id="btnIp">Afișează IP public</button>
              <span class="muted" id="ipInfo"></span>
            </div>
          </div>
          <div style="height:10px"></div>
          <div class="log" id="log"></div>
          <div class="muted" style="margin-top:10px">
            Dacă upload-ul e blocat de CORS în unele rețele, îl poți dezactiva ușor (comentând funcția <code>testUpload</code>).
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const el = (id) => document.getElementById(id);
  const logEl = el("log");

  const ui = {
    btnStart: el("btnStart"),
    btnStop: el("btnStop"),
    btnIp: el("btnIp"),
    status: el("status"),
    ping: el("ping"),
    jitter: el("jitter"),
    loss: el("loss"),
    down: el("down"),
    up: el("up"),
    downBar: el("downBar"),
    upBar: el("upBar"),
    pingSamples: el("pingSamples"),
    timeoutMs: el("timeoutMs"),
    uploadMB: el("uploadMB"),
    downloadMB: el("downloadMB"),
    ipInfo: el("ipInfo"),
  };

  let aborter = null;

  function log(msg) {
    const t = new Date().toLocaleTimeString();
    logEl.textContent += `[${t}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }

  function setStatus(s) { ui.status.textContent = s; }

  function ms(n) { return Math.round(n); }
  function mbps(bytes, seconds) {
    const bits = bytes * 8;
    return (bits / seconds) / 1e6;
  }

  async function fetchWithTimeout(url, opts = {}, timeoutMs = 2500, signal) {
    const controller = new AbortController();
    const t = setTimeout(() => controller.abort(), timeoutMs);

    // combină semnalul extern cu cel intern
    const signals = [controller.signal];
    if (signal) signals.push(signal);

    // Dacă există semnal extern, abortăm intern când externul se oprește.
    let off = null;
    if (signal) {
      const onAbort = () => controller.abort();
      signal.addEventListener("abort", onAbort, { once: true });
      off = () => signal.removeEventListener("abort", onAbort);
    }

    try {
      const res = await fetch(url, { ...opts, cache: "no-store", signal: controller.signal });
      return res;
    } finally {
      clearTimeout(t);
      if (off) off();
    }
  }

  // Ping aproximat: request HTTPS către endpoint-uri rapide.
  // Folosim HEAD/GET către resurse mici. (Unele servere nu acceptă HEAD -> folosim GET.)
  const pingTargets = [
    "https://www.google.com/generate_204",
    "https://www.cloudflare.com/cdn-cgi/trace",
    "https://www.apple.com/library/test/success.html",
  ];

  async function testPing(samples, timeout, signal) {
    log(`Ping test: ${samples} probe, timeout ${timeout}ms ...`);
    const rtts = [];
    let failed = 0;

    for (let i = 0; i < samples; i++) {
      if (signal?.aborted) throw new DOMException("Aborted", "AbortError");

      const target = pingTargets[i % pingTargets.length] + `?t=${Date.now()}_${i}`;
      const t0 = performance.now();

      try {
        // no-cors -> nu putem citi body, dar request-ul se execută și măsurăm durata
        await fetchWithTimeout(target, { method: "GET", mode: "no-cors" }, timeout, signal);
        const t1 = performance.now();
        rtts.push(t1 - t0);
        log(`Ping #${i+1}: ${ms(t1 - t0)} ms`);
      } catch (e) {
        failed++;
        log(`Ping #${i+1}: FAIL (${e.name})`);
      }

      // mică pauză între probe
      await new Promise(r => setTimeout(r, 120));
    }

    const lossPct = (failed / samples) * 100;

    // calc mediană pentru stabilitate
    const sorted = [...rtts].sort((a,b)=>a-b);
    const median = sorted.length ? sorted[Math.floor(sorted.length/2)] : NaN;

    // jitter: deviație medie absolută față de mediană
    let jitter = NaN;
    if (sorted.length) {
      const abs = sorted.map(x => Math.abs(x - median));
      jitter = abs.reduce((a,b)=>a+b,0) / abs.length;
    }

    return {
      medianMs: median,
      jitterMs: jitter,
      lossPct,
      samplesOk: rtts.length,
      samplesTotal: samples,
    };
  }

  // Download test: descarcă un fișier (cu anti-cache) și măsoară timpul total
  // Notă: progres real pe fetch stream e mai complex; aici facem progres aproximativ pe chunks dacă e suportat.
  async function testDownload(mb, signal) {
    // fișiere publice de test (cache-busting). Unele rețele pot bloca anumite domenii.
    // Folosim thinkbroadband (fișiere mari), apoi fallback.
    const urls = [
      `https://speed.hetzner.de/${mb}MB.bin`,
      `https://ipv4.download.thinkbroadband.com/${mb}MB.zip`,
    ];

    for (const base of urls) {
      if (signal?.aborted) throw new DOMException("Aborted", "AbortError");

      const url = base + `?t=${Date.now()}`;
      log(`Download test: ${mb}MB de la ${new URL(base).hostname} ...`);

      try {
        ui.downBar.style.width = "0%";
        const t0 = performance.now();
        const res = await fetchWithTimeout(url, { method: "GET" }, 20000, signal);
        if (!res.ok && res.type !== "opaque") throw new Error(`HTTP ${res.status}`);

        // încearcă streaming pentru progres
        let bytes = 0;
        if (res.body && res.body.getReader) {
          const reader = res.body.getReader();
          const total = Number(res.headers.get("content-length")) || (mb * 1024 * 1024);
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            bytes += value.byteLength;
            const pct = Math.min(100, (bytes / total) * 100);
            ui.downBar.style.width = pct.toFixed(1) + "%";
            if (signal?.aborted) throw new DOMException("Aborted", "AbortError");
          }
        } else {
          // fallback: citește tot
          const blob = await res.blob();
          bytes = blob.size;
          ui.downBar.style.width = "100%";
        }

        const t1 = performance.now();
        const seconds = (t1 - t0) / 1000;
        const speed = mbps(bytes, seconds);

        log(`Download OK: ${ (bytes/1024/1024).toFixed(2) } MB în ${seconds.toFixed(2)} s => ${speed.toFixed(2)} Mbps`);
        return { mbps: speed };
      } catch (e) {
        log(`Download FAIL pe ${new URL(base).hostname}: ${e.message || e.name}`);
      }
    }

    throw new Error("Download test: toate sursele au eșuat (posibil CORS / blocare domeniu).");
  }

  // Upload test: trimite un payload către un endpoint care acceptă POST cu CORS.
  // Folosim https://httpbin.org/post (de obicei are CORS). Dacă e blocat, testul poate eșua.
  async function testUpload(mb, signal) {
    const url = `https://httpbin.org/post?t=${Date.now()}`;
    const bytes = mb * 1024 * 1024;

    log(`Upload test: ${mb}MB către httpbin.org ...`);
    ui.upBar.style.width = "0%";

    // Generează un buffer pseudo-aleator (rapid) - suficient pentru test
    const chunk = new Uint8Array(1024 * 1024); // 1MB
    crypto.getRandomValues(chunk);

    // Construim un Blob din N bucăți de 1MB (evită alocări uriașe deodată)
    const parts = [];
    for (let i = 0; i < mb; i++) parts.push(chunk);
    const blob = new Blob(parts, { type: "application/octet-stream" });

    const t0 = performance.now();
    // Nu avem progres nativ fără XHR; folosim timp scurs ca progres aproximativ.
    // (dacă vrei progres real, pot rescrie pe XMLHttpRequest)
    const progTimer = setInterval(() => {
      // progres fake: până la 95% înainte de finalizare
      const w = parseFloat(ui.upBar.style.width) || 0;
      ui.upBar.style.width = Math.min(95, w + 2).toFixed(1) + "%";
    }, 120);

    try {
      const res = await fetchWithTimeout(url, { method: "POST", body: blob }, 30000, signal);
      clearInterval(progTimer);
      ui.upBar.style.width = "100%";
      if (!res.ok) throw new Error(`HTTP ${res.status}`);

      const t1 = performance.now();
      const seconds = (t1 - t0) / 1000;
      const speed = mbps(bytes, seconds);

      log(`Upload OK: ${mb} MB în ${seconds.toFixed(2)} s => ${speed.toFixed(2)} Mbps`);
      return { mbps: speed };
    } catch (e) {
      clearInterval(progTimer);
      log(`Upload FAIL: ${e.message || e.name}`);
      throw e;
    }
  }

  async function getPublicIp() {
    // ipapi.co de obicei permite CORS și întoarce ISP/ASN etc.
    const res = await fetch("https://ipapi.co/json/", { cache: "no-store" });
    if (!res.ok) throw new Error("Nu pot obține IP.");
    return res.json();
  }

  function formatMaybe(n) {
    if (!Number.isFinite(n)) return "—";
    return n.toFixed(0);
  }

  function setRunning(isRunning) {
    ui.btnStart.disabled = isRunning;
    ui.btnStop.disabled = !isRunning;
  }

  ui.btnStop.addEventListener("click", () => {
    if (aborter) aborter.abort();
  });

  ui.btnIp.addEventListener("click", async () => {
    ui.ipInfo.textContent = "Se obține IP...";
    try {
      const data = await getPublicIp();
      ui.ipInfo.textContent = `${data.ip} • ${data.org || data.asn || "ISP necunoscut"} • ${data.city || ""} ${data.country_name || ""}`.trim();
    } catch (e) {
      ui.ipInfo.textContent = "Eșec la IP (posibil blocat).";
    }
  });

  ui.btnStart.addEventListener("click", async () => {
    aborter = new AbortController();
    const signal = aborter.signal;

    logEl.textContent = "";
    ui.ping.textContent = "—";
    ui.jitter.textContent = "—";
    ui.loss.textContent = "—";
    ui.down.textContent = "—";
    ui.up.textContent = "—";
    ui.downBar.style.width = "0%";
    ui.upBar.style.width = "0%";

    const samples = Math.max(5, Math.min(50, Number(ui.pingSamples.value) || 12));
    const timeout = Math.max(800, Math.min(10000, Number(ui.timeoutMs.value) || 2500));
    const upMB = Number(ui.uploadMB.value) || 5;
    const downMB = Number(ui.downloadMB.value) || 25;

    setRunning(true);
    setStatus("Rulează...");

    try {
      // 1) Ping
      const p = await testPing(samples, timeout, signal);
      ui.ping.textContent = formatMaybe(p.medianMs);
      ui.jitter.textContent = formatMaybe(p.jitterMs);
      ui.loss.textContent = Number.isFinite(p.lossPct) ? p.lossPct.toFixed(0) : "—";
      log(`Rezumat ping: mediană ${ms(p.medianMs)} ms, jitter ${ms(p.jitterMs)} ms, pierderi ${p.lossPct.toFixed(0)}%`);

      // 2) Download
      const d = await testDownload(downMB, signal);
      ui.down.textContent = Number.isFinite(d.mbps) ? d.mbps.toFixed(2) : "—";

      // 3) Upload
      const u = await testUpload(upMB, signal);
      ui.up.textContent = Number.isFinite(u.mbps) ? u.mbps.toFixed(2) : "—";

      setStatus("Gata");
      log("Test complet.");
    } catch (e) {
      if (e.name === "AbortError") {
        setStatus("Oprit");
        log("Test oprit de utilizator.");
      } else {
        setStatus("Eroare");
        log(`Eroare: ${e.message || e}`);
      }
    } finally {
      setRunning(false);
      aborter = null;
    }
  });
})();
</script>
</body>
</html>
