<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8" />
  <title>Demo GPS Coeziv – Static (GitHub Pages)</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f7;
      color: #222;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    header {
      padding: 12px 20px;
      background: #111827;
      color: #f9fafb;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    header h1 {
      font-size: 1.1rem;
      margin: 0;
    }

    .badge {
      font-size: 0.75rem;
      padding: 4px 10px;
      border-radius: 999px;
      background: #374151;
    }

    main {
      display: grid;
      grid-template-columns: 280px 1fr;
      flex: 1;
      overflow: hidden;
    }

    .panel {
      padding: 16px;
      background: #f9fafb;
      border-right: 1px solid #e5e7eb;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .panel h2 {
      margin: 0 0 6px;
      font-size: 0.95rem;
      color: #111827;
    }

    label {
      display: block;
      font-size: 0.8rem;
      color: #4b5563;
      margin-bottom: 4px;
    }

    select, input[type="range"] {
      width: 100%;
      margin-bottom: 8px;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 8px 12px;
      background: #2563eb;
      color: #fff;
      border-radius: 8px;
      font-size: 0.85rem;
      border: none;
      cursor: pointer;
      margin-top: 4px;
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: default;
    }

    .small {
      font-size: 0.8rem;
      color: #6b7280;
    }

    .metrics {
      font-size: 0.8rem;
      padding: 8px;
      background: #eef2ff;
      border-radius: 8px;
    }

    .metric-line {
      margin-bottom: 4px;
    }

    .map-container {
      position: relative;
      background: #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    svg {
      background: #f9fafb;
      border-radius: 16px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.08);
    }

    .node-circle {
      fill: #111827;
    }

    .node-label {
      font-size: 0.8rem;
      fill: #111827;
    }

    .edge-line {
      stroke: #9ca3af;
      stroke-width: 2;
    }

    .edge-line.route {
      stroke: #2563eb;
      stroke-width: 4;
    }

    .info-bubble {
      font-size: 0.75rem;
      fill: #111827;
    }
  </style>
</head>
<body>
  <header>
    <div>
      <div class="badge">Model Coeziv · Demo rutare static</div>
      <h1>GPS Coeziv – timp vs tensiune structurală</h1>
    </div>
  </header>

  <main>
    <aside class="panel">
      <div>
        <h2>Setări rută</h2>
        <label for="srcSelect">Punct de pornire</label>
        <select id="srcSelect"></select>

        <label for="dstSelect">Destinație</label>
        <select id="dstSelect"></select>

        <label for="alphaRange">Prioritate timp (α)</label>
        <input type="range" id="alphaRange" min="0.5" max="2.0" step="0.1" value="1.0">
        <div class="small">α = <span id="alphaValue">1.0</span></div>

        <label for="betaRange">Prioritate stabilitate / tensiune (β)</label>
        <input type="range" id="betaRange" min="0.0" max="4.0" step="0.2" value="2.0">
        <div class="small">β = <span id="betaValue">2.0</span></div>

        <button id="routeBtn" class="btn">Calculează rută coezivă</button>
      </div>

      <div>
        <h2>Metrici rută</h2>
        <div class="metrics" id="metricsBox">
          <div class="metric-line">Noduri: –</div>
          <div class="metric-line">Timp estimat: –</div>
          <div class="metric-line">Tensiune medie: –</div>
          <div class="metric-line">Cost total coeziv: –</div>
        </div>
      </div>

      <div>
        <h2>Explicație</h2>
        <p class="small">
          Acest demo nu caută doar cel mai scurt drum, ci echilibrul între:
        </p>
        <ul class="small">
          <li><b>timp</b> de parcurs (α);</li>
          <li><b>tensiune structurală</b> a segmentelor (β – zone instabile, aglomerate);</li>
        </ul>
        <p class="small">
          Mărește β pentru a evita segmentele „tensionate” chiar dacă timpul crește puțin.
        </p>
      </div>
    </aside>

    <section class="map-container">
      <svg id="mapSvg" width="600" height="400" viewBox="0 0 600 400">
        <!-- desenăm din JS -->
      </svg>
    </section>
  </main>

  <script>
    // ----- Datele "grafului" (echivalent cu structura din Python) -----

    const NODES = ["A", "B", "C", "D", "E", "F"];

    const EDGES = [
      {
        id: "A-B",
        from: "A",
        to: "B",
        length_km: 2.0,
        speed_kmh: 50,
        tension: 0.2,
        traffic: 1.0
      },
      {
        id: "B-C",
        from: "B",
        to: "C",
        length_km: 1.5,
        speed_kmh: 40,
        tension: 0.8,   // segment tensionat
        traffic: 1.3
      },
      {
        id: "A-D",
        from: "A",
        to: "D",
        length_km: 3.0,
        speed_kmh: 60,
        tension: 0.1,
        traffic: 1.0
      },
      {
        id: "D-E",
        from: "D",
        to: "E",
        length_km: 1.8,
        speed_kmh: 50,
        tension: 0.3,
        traffic: 1.0
      },
      {
        id: "E-C",
        from: "E",
        to: "C",
        length_km: 2.2,
        speed_kmh: 50,
        tension: 0.2,
        traffic: 1.0
      },
      {
        id: "C-F",
        from: "C",
        to: "F",
        length_km: 2.5,
        speed_kmh: 50,
        tension: 0.4,
        traffic: 1.0
      },
      {
        id: "E-F",
        from: "E",
        to: "F",
        length_km: 2.0,
        speed_kmh: 60,
        tension: 0.15,
        traffic: 1.0
      }
    ];

    // construim adiacența cu muchii în ambele sensuri
    const ADJ = {};
    NODES.forEach(n => ADJ[n] = []);

    EDGES.forEach(edge => {
      ADJ[edge.from].push(edge); // dus

      const rev = { ...edge, id: edge.id + "_rev", from: edge.to, to: edge.from };
      ADJ[rev.from].push(rev);   // întors
    });

    // ----- UI bindings -----

    const srcSelect   = document.getElementById("srcSelect");
    const dstSelect   = document.getElementById("dstSelect");
    const alphaRange  = document.getElementById("alphaRange");
    const betaRange   = document.getElementById("betaRange");
    const alphaValue  = document.getElementById("alphaValue");
    const betaValue   = document.getElementById("betaValue");
    const routeBtn    = document.getElementById("routeBtn");
    const metricsBox  = document.getElementById("metricsBox");
    const mapSvg      = document.getElementById("mapSvg");

    // Layout fix pentru noduri (un mic "oraș")
    const nodesLayout = {
      "A": { x: 80,  y: 320 },
      "B": { x: 200, y: 260 },
      "C": { x: 360, y: 220 },
      "D": { x: 200, y: 120 },
      "E": { x: 360, y: 140 },
      "F": { x: 520, y: 260 }
    };

    // populăm select-urile
    function initSelects() {
      srcSelect.innerHTML = "";
      dstSelect.innerHTML = "";

      NODES.forEach(n => {
        const o1 = document.createElement("option");
        o1.value = n;
        o1.textContent = n;
        srcSelect.appendChild(o1);

        const o2 = document.createElement("option");
        o2.value = n;
        o2.textContent = n;
        dstSelect.appendChild(o2);
      });

      srcSelect.value = "A";
      dstSelect.value = "F";
    }

    function clearSvg() {
      while (mapSvg.firstChild) {
        mapSvg.removeChild(mapSvg.firstChild);
      }
    }

    function drawGraph(routeEdges = []) {
      clearSvg();

      const edgeGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
      const nodeGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
      mapSvg.appendChild(edgeGroup);
      mapSvg.appendChild(nodeGroup);

      // muchii
      EDGES.forEach(edge => {
        const from = nodesLayout[edge.from];
        const to   = nodesLayout[edge.to];

        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", from.x);
        line.setAttribute("y1", from.y);
        line.setAttribute("x2", to.x);
        line.setAttribute("y2", to.y);
        line.classList.add("edge-line");
        if (routeEdges.includes(edge.id)) {
          line.classList.add("route");
        }
        edgeGroup.appendChild(line);
      });

      // noduri
      NODES.forEach(n => {
        const pos = nodesLayout[n];
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 10);
        circle.classList.add("node-circle");
        nodeGroup.appendChild(circle);

        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.setAttribute("x", pos.x);
        label.setAttribute("y", pos.y - 14);
        label.setAttribute("text-anchor", "middle");
        label.classList.add("node-label");
        label.textContent = n;
        nodeGroup.appendChild(label);
      });
    }

    function updateMetrics(result) {
      if (!result) {
        metricsBox.innerHTML = `
          <div class="metric-line">Noduri: –</div>
          <div class="metric-line">Timp estimat: –</div>
          <div class="metric-line">Tensiune medie: –</div>
          <div class="metric-line">Cost total coeziv: –</div>
        `;
        return;
      }

      const nodes   = result.nodes.join(" → ");
      const time    = result.total_time_min.toFixed(1) + " min";
      const tension = result.avg_tension.toFixed(2);
      const cost    = result.total_cost.toFixed(2);

      metricsBox.innerHTML = `
        <div class="metric-line"><b>Noduri:</b> ${nodes}</div>
        <div class="metric-line"><b>Timp estimat:</b> ${time}</div>
        <div class="metric-line"><b>Tensiune medie:</b> ${tension}</div>
        <div class="metric-line"><b>Cost total coeziv:</b> ${cost}</div>
      `;
    }

    // ---- Algoritm "coeziv" Dijkstra portat din Python ----

    function edgeCost(edge, alpha, beta) {
      const effectiveSpeed = edge.speed_kmh / edge.traffic;
      const timeMin = 60.0 * edge.length_km / Math.max(effectiveSpeed, 1.0);
      const tension = edge.tension;
      return alpha * timeMin + beta * tension;
    }

    function computeRoute(src, dst, alpha = 1.0, beta = 2.0) {
      if (!NODES.includes(src) || !NODES.includes(dst)) {
        return null;
      }

      const dist = {};
      const prev = {};
      NODES.forEach(n => {
        dist[n] = Infinity;
        prev[n] = null;
      });
      dist[src] = 0.0;

      // heap simplu implementat prin iterare (pentru că graful e mic)
      const visited = new Set();

      while (true) {
        // selectăm nodul cu distanță minimă nevizitat
        let u = null;
        let best = Infinity;
        for (const n of NODES) {
          if (!visited.has(n) && dist[n] < best) {
            best = dist[n];
            u = n;
          }
        }
        if (u === null) break;
        if (u === dst) break;

        visited.add(u);

        for (const edge of ADJ[u]) {
          const v = edge.to;
          const c = edgeCost(edge, alpha, beta);
          const newCost = dist[u] + c;
          if (newCost < dist[v]) {
            dist[v] = newCost;
            prev[v] = { node: u, edgeId: edge.id };
          }
        }
      }

      if (!isFinite(dist[dst])) {
        return null;
      }

      // Reconstruim ruta
      const pathNodes = [];
      const pathEdges = [];
      let cur = dst;
      let totalTime = 0.0;
      let totalTension = 0.0;

      while (cur !== null) {
        pathNodes.push(cur);
        const p = prev[cur];
        if (p) {
          const u = p.node;
          const edgeId = p.edgeId;
          pathEdges.push(edgeId);

          const e = ADJ[u].find(e => e.id === edgeId);
          const effectiveSpeed = e.speed_kmh / e.traffic;
          const timeMin = 60.0 * e.length_km / Math.max(effectiveSpeed, 1.0);
          totalTime += timeMin;
          totalTension += e.tension;

          cur = u;
        } else {
          break;
        }
      }

      pathNodes.reverse();
      pathEdges.reverse();

      const avgTension = totalTension / Math.max(pathEdges.length, 1);

      return {
        nodes: pathNodes,
        edges: pathEdges,
        total_time_min: totalTime,
        avg_tension: avgTension,
        total_cost: dist[dst]
      };
    }

    // ---- Evenimente UI ----

    alphaRange.addEventListener("input", () => {
      alphaValue.textContent = alphaRange.value;
    });

    betaRange.addEventListener("input", () => {
      betaValue.textContent = betaRange.value;
    });

    routeBtn.addEventListener("click", () => {
      const src   = srcSelect.value;
      const dst   = dstSelect.value;
      const alpha = parseFloat(alphaRange.value);
      const beta  = parseFloat(betaRange.value);

      const result = computeRoute(src, dst, alpha, beta);
      if (!result) {
        updateMetrics(null);
        drawGraph([]);
        return;
      }

      updateMetrics(result);
      // colorăm doar muchiile "de bază" (fără _rev)
      const edgeIds = result.edges.map(eid => eid.replace("_rev", ""));
      drawGraph(edgeIds);
    });

    // init
    initSelects();
    drawGraph([]);
  </script>
</body>
</html>
