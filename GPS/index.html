<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GPS Coeziv</title>

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <style>
    * { box-sizing: border-box; }
    html, body {
      margin:0;
      padding:0;
      height:100%;
    }
    body {
      font-family: system-ui, sans-serif;
      background:#020617;
      overflow:hidden;
    }
    #map { width:100%; height:100%; }

    /*----------------
      PANEL JOS
    ----------------*/
    .panel {
      position:absolute;
      left:0; right:0; bottom:0;
      background:rgba(15,23,42,0.97);
      color:#e5e7eb;
      padding:10px 12px 14px;
      box-shadow:0 -8px 20px rgba(0,0,0,0.6);
      z-index:1000;
    }
    .panel-inner {
      max-width:900px;
      margin:0 auto;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .panel-row {
      display:flex;
      align-items:center;
      gap:8px;
    }
    .brand {
      font-size:0.95rem;
      font-weight:600;
      flex:1;
    }

    .btn {
      border-radius:999px;
      border:none;
      padding:10px 14px;
      background:#1f2937;
      color:#e5e7eb;
      font-size:0.9rem;
      cursor:pointer;
    }
    .btn-primary {
      background:#2563eb;
      color:white;
      flex:1;
      font-size:1rem;
      font-weight:600;
    }
    .btn-circle { padding:8px 10px; min-width:40px; }

    /*----------------
      INPUT DESTINA»öIE
    ----------------*/
    .input-wrap { flex:1; position:relative; }
    .search-input {
      width:100%;
      border-radius:999px;
      border:1px solid #4b5563;
      padding:10px 14px;
      font-size:0.9rem;
      background:#020617;
      color:#e5e7eb;
    }
    .search-input::placeholder { color:#6b7280; }

    .suggestions {
      display:none;
      position:absolute;
      bottom:110%;
      left:0; right:0;
      background:#020617;
      border:1px solid #4b5563;
      border-radius:12px;
      max-height:260px;
      overflow-y:auto;
      box-shadow:0 12px 28px rgba(0,0,0,0.7);
      z-index:2000;
    }
    .suggestion-item {
      padding:10px 12px;
      cursor:pointer;
      line-height:1.3;
    }
    .suggestion-item:hover { background:#1e293b; }

    /*----------------
      ROUTE PANEL
    ----------------*/
    .route-info {
      background:#0b1120;
      padding:6px 10px;
      border-radius:999px;
      font-size:0.85rem;
      display:flex;
      gap:6px;
      align-items:center;
    }
    .dot-origin{color:#4ade80;}
    .dot-dest{color:#f87171;}
    .dot-route{color:#60a5fa;}

    /*----------------
      TOAST
    ----------------*/
    .toast {
      position:absolute;
      left:50%;
      bottom:52px;
      transform:translateX(-50%);
      background:rgba(15,23,42,0.98);
      padding:8px 12px;
      border-radius:10px;
      color:#e5e7eb;
      font-size:0.9rem;
      opacity:0;
      pointer-events:none;
      transition:opacity .2s;
      z-index:9999;
    }
    .toast.show { opacity:1; }

    /*----------------
      NAV BANNER SUS
    ----------------*/
    .nav-banner{
      position:absolute;
      top:10px;
      left:50%;
      transform:translateX(-50%);
      background:#0f172a;
      border:1px solid #1d4ed8;
      padding:10px 14px;
      border-radius:18px;
      z-index:1500;
      color:white;
      max-width:95vw;
      box-shadow:0 10px 25px rgba(0,0,0,0.5);
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .nav-row-main{display:flex;align-items:center;gap:10px;}
    .nav-arrow{font-size:1.3rem;}
    .nav-distance{ color:#93c5fd; font-size:0.85rem; }
    .nav-row-extra{display:flex;gap:8px;font-size:.8rem;}
    .nav-warn{ color:#facc15; }
    .nav-lane{ font-family:monospace; color:#bfdbfe; }
    .nav-complexity{ color:#a5b4fc; }
    .nav-mode-chip{
      margin-left:auto;
      background:#0b1120;
      padding:3px 6px;
      border-radius:999px;
      border:1px solid #1e3a8a;
      font-size:.75rem;
    }

    /*---------------
      ARROW MARKER
    ----------------*/
    .arrow-icon{
      width:26px;height:26px;
      border-radius:50%;
      border:2px solid #2563eb;
      background:rgba(37,99,235,.18);
      display:flex;
      align-items:center;
      justify-content:center;
      transform-origin:center;
    }
    .arrow-icon span{
      font-size:16px;
      color:#2563eb;
      transform:translateY(-2px);
    }

    /*---------------
      TOGGLE GROUP
    ----------------*/
    .toggle-group{
      display:inline-flex;
      background:#020617;
      border-radius:999px;
      padding:2px;
      border:1px solid #4b5563;
    }
    .toggle{
      border:none;
      background:transparent;
      color:#9ca3af;
      padding:5px 8px;
      border-radius:999px;
      cursor:pointer;
    }
    .toggle.active{
      background:#1d4ed8;
      color:#f9fafb;
    }
  </style>
</head>

<body>

  <!-- MAPA -->
  <div id="map"></div>

  <!-- HUD DE NAVIGA»öIE -->
  <div id="navBanner" class="nav-banner">
    <div class="nav-row-main">
      <span class="nav-arrow">‚¨ÜÔ∏è</span>
      <span id="navText">PregƒÉtit. Alege destina»õia »ôi apasƒÉ ‚ÄûStart naviga»õie‚Äù.</span>
      <span id="navDist" class="nav-distance"></span>
    </div>
    <div class="nav-row-extra">
      <span id="navWarn" class="nav-warn"></span>
      <span id="navLane" class="nav-lane"></span>
      <span id="navComplexity" class="nav-complexity"></span>
      <span id="navModeChip" class="nav-mode-chip">Auto ¬∑ Echilibrat</span>
    </div>
  </div>

  <!-- PANEL JOS -->
  <div class="panel">
    <div class="panel-inner">

      <div class="panel-row">
        <div class="brand">GPS Coeziv</div>

        <div id="modeGroup" class="toggle-group">
          <button class="toggle active" data-mode="driving">üöó</button>
          <button class="toggle" data-mode="cycling">üö≤</button>
          <button class="toggle" data-mode="walking">üö∂</button>
        </div>

        <button id="gpsBtn" class="btn btn-circle">GPS</button>
        <button id="fsBtn" class="btn btn-circle">‚§¢</button>
      </div>

      <div class="panel-row">
        <div class="input-wrap">
          <input id="addressInput" class="search-input" placeholder="Introdu destina»õia‚Ä¶" />
          <div id="suggestions" class="suggestions"></div>
        </div>
      </div>

      <div class="panel-row">
        <button id="startBtn" class="btn btn-primary">Start naviga»õie</button>
      </div>

      <div class="panel-row" style="justify-content:space-between;">
        <div class="info-small">
          Tap = destina»õie ¬∑ Alt+Tap = origine
          <br>Profil:
          <span id="profileGroup" class="toggle-group">
            <button class="toggle" data-prof="fast">‚ö°</button>
            <button class="toggle active" data-prof="balanced">‚öñÔ∏è</button>
            <button class="toggle" data-prof="stable">üß±</button>
          </span>
        </div>
        <div class="route-info">
          <span class="dot-origin">‚óè</span>O
          <span class="dot-dest">‚óè</span>D
          <span class="dot-route">‚îÅ</span>
          <span id="routeText">‚Äì</span>
        </div>
      </div>

    </div>
  </div>

  <div id="toast" class="toast"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    /*  
      --------
      AICI √éNCEPE LOGICA GPS COEZIV COMPLETƒÇ  
      CU TOATE UPGRADE-URILE INTEGRATE:
      - hartƒÉ dark high-contrast
      - zoom inteligent 17
      - smooth GPS animation
      - coeziv Œ±/Œ≤/Œ≥/Œ¥
      - radar/curbe/benzi
      - rerutare live
      - autocomplete
      - full screen
    --------
    */

    //-----------------------
    //  PARAMETRI COEZIVI
    //-----------------------
    let COHESION_ALPHA = 1.2;
    let COHESION_BETA  = 1.2;
    let COHESION_GAMMA = 1.0;
    let COHESION_DELTA = 0.8;

    const COHESION_PROFILES = {
      fast:     { alpha:1.8, beta:0.7, gamma:0.7, delta:0.5 },
      balanced: { alpha:1.2, beta:1.2, gamma:1.0, delta:0.8 },
      stable:   { alpha:0.8, beta:1.8, gamma:1.5, delta:1.2 }
    };

    let transportMode = "driving";
    let cohesionProfile = "balanced";

    function applyCohesionProfile() {
      const p = COHESION_PROFILES[cohesionProfile];
      COHESION_ALPHA = p.alpha;
      COHESION_BETA  = p.beta;
      COHESION_GAMMA = p.gamma;
      COHESION_DELTA = p.delta;
      updateModeChip();
    }

    //-----------------------
    //   INIT MAP (dark + zoom close)
    //-----------------------
    const map = L.map("map").setView([45.94,24.97], 6);

    L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png", {
      maxZoom:19,
      attribution:'&copy; OpenStreetMap, &copy; CARTO'
    }).addTo(map);

    //-----------------------
    //  ELEMENTE UI
    //-----------------------
    const gpsBtn = document.getElementById("gpsBtn");
    const fsBtn = document.getElementById("fsBtn");
    const addressInput = document.getElementById("addressInput");
    const suggestionsEl = document.getElementById("suggestions");
    const startBtn = document.getElementById("startBtn");
    const toastEl = document.getElementById("toast");

    const navTextEl = document.getElementById("navText");
    const navDistEl = document.getElementById("navDist");
    const navArrowEl = document.querySelector(".nav-arrow");
    const navWarnEl = document.getElementById("navWarn");
    const navLaneEl = document.getElementById("navLane");
    const navComplexityEl = document.getElementById("navComplexity");
    const navModeChipEl = document.getElementById("navModeChip");

    const routeTextEl = document.getElementById("routeText");
    const modeGroup = document.getElementById("modeGroup");
    const profileGroup = document.getElementById("profileGroup");

    //-----------------------
    //   STATE GPS
    //-----------------------
    let originLatLng = null;
    let destLatLng = null;
    let originMarker = null;
    let destMarker = null;

    let routeLayers = [];
    let bestRouteLayer = null;

    let userMarker = null;
    let gpsWatchId = null;
    let gpsTargetPoint = null;
    let gpsAnimPoint = null;
    let userPrevPoint = null;
    let lastAnimTime = null;

    let navigationActive = false;

    let routeCoords = [];
    let routeSteps  = [];
    let currentStepIndex = 0;
    let lastSpokenStepIndex = -1;

    //-----------------------
    //   ARROW MARKER
    //-----------------------
    const arrowIcon = L.divIcon({
      className:"arrow-icon",
      html:"<span>‚ñ≤</span>",
      iconSize:[26,26],
      iconAnchor:[13,13]
    });

    //-----------------------
    //    TOAST
    //-----------------------
    function showToast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      setTimeout(()=>toastEl.classList.remove("show"),2200);
    }

    //-----------------------
    //   SET ORIGIN / DEST
    //-----------------------
    function setOrigin(lat, lon, label){
      originLatLng = [lat,lon];
      if(originMarker) map.removeLayer(originMarker);
      originMarker = L.marker(originLatLng).addTo(map).bindPopup(label).openPopup();
    }

    function setDest(lat, lon, label){
      destLatLng = [lat,lon];
      if(destMarker) map.removeLayer(destMarker);
      destMarker = L.marker(destLatLng).addTo(map).bindPopup(label).openPopup();
    }

    //-----------------------
    //   GET GPS
    //-----------------------
    function getGPSOrigin(showMsg=true){
      if(!navigator.geolocation){
        showToast("GPS indisponibil.");
        return;
      }
      navigator.geolocation.getCurrentPosition(
        pos=>{
          const lat = pos.coords.latitude;
          const lon = pos.coords.longitude;
          setOrigin(lat,lon,"Origine (GPS)");
          map.setView([lat,lon],17);
          if(showMsg) showToast("Origine din GPS.");
        },
        ()=> showToast("Nu pot ob»õine GPS.")
      );
    }

    //-----------------------
    //   FULLSCREEN
    //-----------------------
    fsBtn.onclick = () => {
      if (!document.fullscreenElement)
        document.documentElement.requestFullscreen();
      else
        document.exitFullscreen();
    };

    //-----------------------
    //  MAP CLICK (origin/dest)
    //-----------------------
    map.on("click",e=>{
      if(e.originalEvent.altKey){
        setOrigin(e.latlng.lat,e.latlng.lng,"Origine (Alt+Tap)");
        showToast("Origine setatƒÉ");
      } else {
        setDest(e.latlng.lat,e.latlng.lng,"Destina»õie");
        showToast("Destina»õie setatƒÉ");
      }
    });

    //-----------------------
    // MODE SWITCH
    //-----------------------
    modeGroup.addEventListener("click",e=>{
      if(!e.target.dataset.mode) return;
      transportMode=e.target.dataset.mode;

      [...modeGroup.querySelectorAll(".toggle")].forEach(b=>b.classList.toggle("active",b===e.target));

      updateModeChip();
      showToast(
        transportMode==="driving" ? "Mod Auto" :
        transportMode==="cycling" ? "Mod BicicletƒÉ" :
                                    "Mod Pe jos"
      );
    });

    function updateModeChip(){
      const m =
        transportMode==="driving" ? "Auto" :
        transportMode==="cycling"? "Bike":"Walk";
      const p =
        cohesionProfile==="fast"?"Rapid":
        cohesionProfile==="balanced"?"Echilibrat": "Stabil";
      navModeChipEl.textContent = `${m} ¬∑ ${p}`;
    }

    //-----------------------
    // PROFILE SWITCH
    //-----------------------
    profileGroup.addEventListener("click",e=>{
      if(!e.target.dataset.prof) return;
      cohesionProfile = e.target.dataset.prof;

      [...profileGroup.querySelectorAll(".toggle")].forEach(b=>b.classList.toggle("active",b===e.target));
      applyCohesionProfile();
      showToast(
        cohesionProfile==="fast"?"Rapid":
        cohesionProfile==="balanced"?"Echilibrat":"Stabil"
      );
    });

    //-----------------------
    // AUTOCOMPLETE
    //-----------------------
    let autocompleteTimeout=null;

    addressInput.addEventListener("input",()=>{
      const q=addressInput.value.trim();
      destLatLng=null;

      if(q.length<3){
        suggestionsEl.style.display="none";
        return;
      }
      if(autocompleteTimeout) clearTimeout(autocompleteTimeout);
      autocompleteTimeout=setTimeout(()=>fetchSuggestions(q),350);
    });

    async function fetchSuggestions(query){
      const url=`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&addressdetails=1`;
      const r= await fetch(url);
      const data= await r.json();

      suggestionsEl.innerHTML="";
      if(!data || !data.length){
        suggestionsEl.style.display="none";
        return;
      }

      data.forEach(item=>{
        const div=document.createElement("div");
        div.className="suggestion-item";
        div.textContent=item.display_name;
        div.onclick=()=>chooseSuggestion(item);
        suggestionsEl.appendChild(div);
      });

      suggestionsEl.style.display="block";
    }

    function chooseSuggestion(item){
      const lat=+item.lat;
      const lon=+item.lon;
      setDest(lat,lon,item.display_name);
      map.setView([lat,lon],17);
      addressInput.value=item.display_name;
      suggestionsEl.style.display="none";
      showToast("Destina»õie selectatƒÉ");
    }

    document.addEventListener("click",e=>{
      if(e.target!==addressInput && !suggestionsEl.contains(e.target)){
        suggestionsEl.style.display="none";
      }
    });

    //-----------------------
    // GEO UTILS
    //-----------------------
    function haversine(lat1,lon1,lat2,lon2){
      const R=6371000;
      const toRad=d=>(d*Math.PI/180);
      const dLat=toRad(lat2-lat1);
      const dLon=toRad(lon2-lon1);
      const a = Math.sin(dLat/2)**2 +
        Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*
        Math.sin(dLon/2)**2;
      return 2*R*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
    }

    function minDistanceToRoute(p,poly){
      let m=Infinity;
      for(const [la,lo] of poly){
        const d=haversine(p[0],p[1],la,lo);
        if(d<m) m=d;
      }
      return m;
    }

    function bearingDeg(a,b){
      const toRad = d=>d*Math.PI/180;
      const toDeg = r=>r*180/Math.PI;

      const [lat1,lon1]=a;
      const [lat2,lon2]=b;

      const œÜ1=toRad(lat1);
      const œÜ2=toRad(lat2);
      const Œª1=toRad(lon1);
      const Œª2=toRad(lon2);

      const y=Math.sin(Œª2-Œª1)*Math.cos(œÜ2);
      const x=Math.cos(œÜ1)*Math.sin(œÜ2)-Math.sin(œÜ1)*Math.cos(œÜ2)*Math.cos(Œª2-Œª1);
      return (toDeg(Math.atan2(y,x))+360)%360;
    }

    function renderLaneHint(l){
      if(!l || !l.length) return "";
      return l.map(x=>x.valid?"üü¶":"‚¨õ").join(" ");
    }

    //-----------------------
    //   MANEUVER TEXT
    //-----------------------
    function maneuverToText(step){
      if(!step || !step.maneuver) return{ text:"UrmeazƒÉ ruta", arrow:"‚¨ÜÔ∏è" };
      const m=step.maneuver;
      const type=m.type||"";
      const mod=m.modifier||"";
      const name=step.name||"";

      let arrow="‚¨ÜÔ∏è";
      if(mod==="left") arrow="‚¨ÖÔ∏è";
      else if(mod==="right") arrow="‚û°Ô∏è";
      else if(mod==="slight left") arrow="‚ÜñÔ∏è";
      else if(mod==="slight right") arrow="‚ÜóÔ∏è";
      else if(type==="roundabout") arrow="‚≠ï";

      let base="";
      if(type==="turn"){
        base=mod==="left"?"VireazƒÉ la st√¢nga":
             mod==="right"?"VireazƒÉ la dreapta":
             "VireazƒÉ";
      }
      else if(type==="continue"||type==="new name") base="ContinuƒÉ √Ænainte";
      else if(type==="roundabout") base="IntrƒÉ √Æn sensul giratoriu";
      else if(type==="depart") base="Porne»ôte pe traseu";
      else if(type==="arrive") base="Ai ajuns la destina»õie";
      else base="UrmeazƒÉ ruta";

      if(name) base+=` pe ${name}`;
      return{ text:base, arrow };
    }

    //-----------------------
    //   SPEECH
    //-----------------------
    function speak(t){
      if(!("speechSynthesis" in window)) return;
      const u=new SpeechSynthesisUtterance(t);
      u.lang="ro-RO";
      speechSynthesis.speak(u);
    }

    //-----------------------
    // SMOOTH GPS ANIMATION
    //-----------------------
    function animationLoop(ts){
      if(userMarker && gpsTargetPoint){
        if(!gpsAnimPoint) gpsAnimPoint=gpsTargetPoint.slice();
        if(lastAnimTime==null) lastAnimTime=ts;
        const dt=(ts-lastAnimTime)/1000;
        lastAnimTime=ts;

        const speed=4;
        const a=Math.min(1,dt*speed);
        gpsAnimPoint[0]+= (gpsTargetPoint[0]-gpsAnimPoint[0])*a;
        gpsAnimPoint[1]+= (gpsTargetPoint[1]-gpsAnimPoint[1])*a;

        userMarker.setLatLng(gpsAnimPoint);
      }
      requestAnimationFrame(animationLoop);
    }
    requestAnimationFrame(animationLoop);

    //-----------------------
    //   RUTARE + COEZIV
    //-----------------------
    async function computeCohesiveRoute(fromReroute=false){
      if(!originLatLng){ showToast("SeteazƒÉ originea."); return; }
      if(!destLatLng){ showToast("SeteazƒÉ destina»õia."); return; }

      const src=originLatLng;
      const dst=destLatLng;

      const url=`https://router.project-osrm.org/route/v1/${transportMode}/${src[1]},${src[0]};${dst[1]},${dst[0]}?overview=full&steps=true&alternatives=true&geometries=geojson`;

      if(!fromReroute){
        startBtn.disabled=true;
        startBtn.textContent="Se calculeazƒÉ...";
      }

      clearRoutes();

      try{
        const r=await fetch(url);
        if(!r.ok){
          showToast("Rutarea offline - doar hartƒÉ.");
          return;
        }

        const data=await r.json();
        if(!data.routes || !data.routes.length){
          showToast("Nicio rutƒÉ.");
          return;
        }

        //-------------------
        //  CALCUL COEZIV
        //-------------------
        const enriched=data.routes.map((rt)=>{
          let maneuvers=0;
          let microTension=0;
          let intersectionsCount=0;
          const stepsFlat=[];

          rt.legs.forEach(leg=>{
            leg.steps.forEach((s,idx)=>{
              maneuvers++;

              const meta={curve:false,crossing:false,radar:false,lanes:null};

              if(s.maneuver &&
                ((s.maneuver.type==="turn" && s.distance<60) ||
                 s.maneuver.type==="roundabout")){
                meta.curve=true;
                microTension+=1.0;
              }

              if(s.intersections){
                intersectionsCount+=s.intersections.length;
                const hasSignal=s.intersections.some(i=>i.traffic_signal);
                if(hasSignal){
                  meta.crossing=true;
                  microTension+=0.7;
                }
                const i2=s.intersections.find(i=>i.lanes && i.lanes.length);
                if(i2) meta.lanes=i2.lanes;
              }

              if(!meta.curve && !meta.crossing && s.distance>180 && idx%5===0){
                meta.radar=true;
                microTension+=0.5;
              }

              s._coezivMeta=meta;
              stepsFlat.push(s);
            });
          });

          const distKm=rt.distance/1000;
          const density=distKm>0?intersectionsCount/distKm:0;

          const tMin=rt.duration/60;

          const cost = COHESION_ALPHA*tMin +
                       COHESION_BETA*maneuvers +
                       COHESION_GAMMA*microTension +
                       COHESION_DELTA*density;

          return {
            route:rt,
            maneuvers,
            microTension,
            density,
            cost,
            stepsFlat,
            distanceM:rt.distance,
            timeMin:tMin
          };
        });

        enriched.sort((a,b)=>a.cost-b.cost);
        const best=enriched[0];

        //-------------------
        //   DESENEAZƒÇ TOATE
        //-------------------
        enriched.forEach(r=>{
          const coords=r.route.geometry.coordinates.map(c=>[c[1],c[0]]);
          const poly=L.polyline(coords,{color:"#64748b",weight:3,opacity:.5}).addTo(map);
          routeLayers.push(poly);
        });

        //-------------------
        //   DESENEAZƒÇ BEST
        //-------------------
        routeCoords=best.route.geometry.coordinates.map(c=>[c[1],c[0]]);
        bestRouteLayer=L.polyline(routeCoords,{color:"#2563EB",weight:7}).addTo(map);
        map.fitBounds(bestRouteLayer.getBounds(),{padding:[50,180],maxZoom:17});

        routeSteps=best.stepsFlat;
        currentStepIndex=0;
        lastSpokenStepIndex=-1;

        routeTextEl.textContent=`${(best.distanceM/1000).toFixed(1)} km ¬∑ ${best.timeMin.toFixed(0)} min ¬∑ ${best.maneuvers} manevre`;

        // complexitate
        const c=best.density;
        navComplexityEl.textContent =
          c<10 ? "Complexitate: scƒÉzutƒÉ":
          c<20 ? "Complexitate: medie":
                 "Complexitate: mare";

        const first=routeSteps[0];
        const t2=maneuverToText(first);
        navArrowEl.textContent=t2.arrow;
        navTextEl.textContent=t2.text;

        navWarnEl.textContent="";
        navLaneEl.textContent="";

        if(!fromReroute){
          showToast("RutƒÉ CoezivƒÉ calculatƒÉ.");
          startNavigationTracking();
        }
        else showToast("Rerutare efectuatƒÉ.");

      } catch(err){
        showToast("Offline: harta merge, rutare nu.");
      } finally {
        if(!fromReroute){
          startBtn.disabled=false;
          startBtn.textContent="Start naviga»õie";
        }
      }
    }

    //-----------------------
    //   NAV LIVE TRACKING
    //-----------------------
    function startNavigationTracking(){
      navigationActive=true;

      if(!navigator.geolocation){
        showToast("GPS live indisponibil.");
        return;
      }

      if(gpsWatchId!==null) return;

      gpsWatchId=navigator.geolocation.watchPosition(
        pos=>{
          const lat=pos.coords.latitude;
          const lon=pos.coords.longitude;

          gpsTargetPoint=[lat,lon];

          if(!userMarker){
            userMarker=L.marker([lat,lon],{icon:arrowIcon}).addTo(map);
            gpsAnimPoint=[lat,lon];
          }

          if(userPrevPoint){
            const br=bearingDeg(userPrevPoint,[lat,lon]);
            const el=userMarker.getElement();
            if(el) el.style.transform=`rotate(${br}deg)`;
          }
          userPrevPoint=[lat,lon];

          // zoom adaptiv
          let Z=15;
          if(routeSteps.length){
            const step=routeSteps[currentStepIndex];
            const loc=step.maneuver.location;
            const d=haversine(lat,lon,loc[1],loc[0]);
            if(d>1500) Z=14;
            else if(d>400) Z=15;
            else Z=17;
          }

          map.setView([lat,lon],Math.max(map.getZoom(),Z),{animate:true});

          if(!navigationActive || !routeCoords.length) return;

          const dRoute=minDistanceToRoute([lat,lon],routeCoords);
          const thr =
            transportMode==="walking"?60:
            transportMode==="cycling"?100:
                                      150;

          if(dRoute>thr){
            showToast("Rerutare‚Ä¶");
            originLatLng=[lat,lon];
            computeCohesiveRoute(true);
            return;
          }

          updateTurnByTurn([lat,lon]);
        },
        ()=>showToast("Eroare GPS live."),
        {enableHighAccuracy:true,maximumAge:2000,timeout:10000}
      );
    }

    //-----------------------
    // STEP BY STEP
    //-----------------------
    function updateTurnByTurn(p){
      if(!routeSteps.length){
        navTextEl.textContent="UrmeazƒÉ ruta.";
        navDistEl.textContent="";
        navWarnEl.textContent="";
        navLaneEl.textContent="";
        return;
      }

      let bestIdx=currentStepIndex;
      let bestD=Infinity;

      for(let i=currentStepIndex;i<Math.min(routeSteps.length,currentStepIndex+8);i++){
        const s=routeSteps[i];
        const loc=s.maneuver.location;
        const d=haversine(p[0],p[1],loc[1],loc[0]);
        if(d<bestD){ bestD=d; bestIdx=i; }
      }
      currentStepIndex=bestIdx;
      const step=routeSteps[currentStepIndex];

      const {text,arrow}=maneuverToText(step);
      navArrowEl.textContent=arrow;
      navTextEl.textContent=text;

      const loc=step.maneuver.location;
      const d=haversine(p[0],p[1],loc[1],loc[0]);

      const dd = d>1000? `${(d/1000).toFixed(1)} km` : `${Math.round(d)} m`;
      navDistEl.textContent=d<15?"acum":`√Æn ${dd}`;

      const meta=step._coezivMeta||{};
      navWarnEl.textContent = meta.curve?"üöß CurbƒÉ str√¢nsƒÉ":
                               meta.crossing?"üö∏ Trecere pietoni":
                               meta.radar?"üì∏ ZonƒÉ radar":"",
                               "";
      navLaneEl.textContent=renderLaneHint(meta.lanes);

      if(currentStepIndex!==lastSpokenStepIndex && d<120){
        let sp=text;
        if(meta.curve) sp="Aten»õie curbƒÉ str√¢nsƒÉ. "+sp;
        if(meta.crossing) sp="Aten»õie trecere pietoni. "+sp;
        if(meta.radar) sp="Posibil radar. "+sp;

        speak(sp);
        lastSpokenStepIndex=currentStepIndex;
      }

      if(d<20 && currentStepIndex<routeSteps.length-1){
        currentStepIndex++;
      }
    }

    //-----------------------
    // CLEAR ROUTES
    //-----------------------
    function clearRoutes(){
      routeLayers.forEach(l=>map.removeLayer(l));
      routeLayers=[];
      if(bestRouteLayer){
        map.removeLayer(bestRouteLayer);
        bestRouteLayer=null;
      }
      routeCoords=[];
      routeSteps=[];
      currentStepIndex=0;
      lastSpokenStepIndex=-1;
      routeTextEl.textContent="‚Äì";
      navWarnEl.textContent="";
      navLaneEl.textContent="";
    }

    //-----------------------
    //  START BUTTON
    //-----------------------
    startBtn.onclick=()=>computeCohesiveRoute(false);

    //-----------------------
    // ONLOAD
    //-----------------------
    window.onload=()=>{
      applyCohesionProfile();
      getGPSOrigin(false);
    };
  </script>

</body>
</html>
