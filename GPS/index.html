<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>GPS Coeziv</title>

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin=""
  />

  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      overflow: hidden;
    }
    #map {
      width: 100%;
      height: 100%;
    }

    /* Panou jos */
    .panel {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(15,23,42,0.97);
      color: #e5e7eb;
      padding: 10px 12px 14px;
      box-shadow: 0 -8px 20px rgba(0,0,0,0.6);
      z-index: 1000;
    }
    .panel-inner {
      max-width: 900px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .panel-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .brand {
      font-size: 0.95rem;
      font-weight: 600;
      flex: 1;
      white-space: nowrap;
    }

    .btn {
      border-radius: 999px;
      border: none;
      padding: 10px 14px;
      font-size: 0.9rem;
      background: #1f2937;
      color: #e5e7eb;
      cursor: pointer;
      font-weight: 500;
      white-space: nowrap;
    }
    .btn-primary {
      background: #2563eb;
      color: #fff;
      flex: 1;
      font-weight: 600;
      text-align: center;
    }
    .btn:disabled {
      opacity: 0.6;
      cursor: default;
    }

    .btn-circle {
      border-radius: 999px;
      padding: 8px 10px;
      min-width: 40px;
      text-align: center;
    }

    .input-wrap {
      position: relative;
      flex: 1;
    }
    .search-input {
      width: 100%;
      border-radius: 999px;
      border: 1px solid #4b5563;
      padding: 10px 14px;
      font-size: 0.9rem;
      background: #020617;
      color: #e5e7eb;
      outline: none;
    }
    .search-input::placeholder {
      color: #6b7280;
    }

    .suggestions {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 110%;
      background: #020617;
      border-radius: 12px;
      border: 1px solid #4b5563;
      box-shadow: 0 12px 28px rgba(0,0,0,0.7);
      max-height: 260px;
      overflow-y: auto;
      font-size: 0.9rem;
      z-index: 1100;
    }
    .suggestion-item {
      padding: 10px 12px;
      cursor: pointer;
      line-height: 1.3;
    }
    .suggestion-item:hover {
      background: #1e293b;
    }

    .info-small {
      font-size: 0.8rem;
      color: #9ca3af;
    }

    .route-info {
      font-size: 0.85rem;
      padding: 6px 10px;
      border-radius: 999px;
      background: #0b1120;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      align-self: center;
      white-space: nowrap;
    }

    .dot-origin { color:#4ade80; font-size: 1.2rem; }
    .dot-dest   { color:#f97373; font-size: 1.2rem; }
    .dot-route  { color:#60a5fa; font-size: 1.2rem; }

    .toast {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 52px;
      background: rgba(15,23,42,0.98);
      color: #e5e7eb;
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 0.9rem;
      max-width: 90vw;
      text-align: center;
      z-index: 1100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }
    .toast.show { opacity: 1; }

    /* Banner naviga»õie sus */
    .nav-banner {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(90deg,#0f172a,#111827);
      color: #e5e7eb;
      padding: 8px 14px;
      border-radius: 999px;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 10px;
      z-index: 1000;
      max-width: 95vw;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      box-shadow: 0 10px 25px rgba(0,0,0,0.5);
      border: 1px solid #1d4ed8;
    }
    .nav-arrow {
      font-size: 1.3rem;
    }
    .nav-distance {
      font-size: 0.85rem;
      color: #93c5fd;
      margin-left: 4px;
    }
    .nav-mode-chip {
      font-size: 0.75rem;
      background: #0b1120;
      padding: 3px 6px;
      border-radius: 999px;
      border: 1px solid #1e3a8a;
    }

    /* marker sƒÉgeatƒÉ GPS */
    .arrow-icon {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      background: rgba(37,99,235,0.18);
      border: 2px solid #2563eb;
      display: flex;
      align-items: center;
      justify-content: center;
      transform-origin: center;
    }
    .arrow-icon span {
      display: block;
      font-size: 16px;
      color: #2563eb;
      transform: translateY(-2px);
    }

    /* toggle groups */
    .toggle-group {
      display: inline-flex;
      background: #020617;
      border-radius: 999px;
      padding: 2px;
      border: 1px solid #4b5563;
      gap: 2px;
    }
    .toggle {
      border: none;
      border-radius: 999px;
      padding: 5px 8px;
      font-size: 0.8rem;
      background: transparent;
      color: #9ca3af;
      cursor: pointer;
      min-width: 40px;
    }
    .toggle.active {
      background: #1d4ed8;
      color: #f9fafb;
    }

    @media (min-width: 768px) {
      .panel {
        left: 50%;
        transform: translateX(-50%);
        border-radius: 16px 16px 0 0;
      }
    }
  </style>
</head>

<body>
  <div id="map"></div>

  <!-- Banner naviga»õie -->
  <div id="navBanner" class="nav-banner">
    <span class="nav-arrow">‚¨ÜÔ∏è</span>
    <span id="navText">PregƒÉtit. Alege destina»õia »ôi apasƒÉ ‚ÄûStart naviga»õie‚Äù.</span>
    <span id="navDist" class="nav-distance"></span>
    <span id="navModeChip" class="nav-mode-chip">Auto ¬∑ Echilibrat</span>
  </div>

  <!-- PANOU JOS -->
  <div class="panel">
    <div class="panel-inner">

      <div class="panel-row">
        <div class="brand">GPS Coeziv</div>
        <div class="toggle-group" id="modeGroup">
          <button class="toggle active" data-mode="driving">üöó</button>
          <button class="toggle" data-mode="cycling">üö≤</button>
          <button class="toggle" data-mode="walking">üö∂</button>
        </div>
        <button id="gpsBtn" class="btn btn-circle">GPS</button>
        <button id="fsBtn" class="btn btn-circle">‚§¢</button>
      </div>

      <div class="panel-row">
        <div class="input-wrap">
          <input
            id="addressInput"
            class="search-input"
            type="text"
            placeholder="Introdu destina»õia..."
            autocomplete="off"
          />
          <div id="suggestions" class="suggestions" style="display:none;"></div>
        </div>
      </div>

      <div class="panel-row">
        <button id="startBtn" class="btn btn-primary">Start naviga»õie</button>
      </div>

      <div class="panel-row" style="justify-content: space-between;">
        <div class="info-small">
          Tap = destina»õie ¬∑ Alt+Tap = origine
          <br />
          Profil:
          <span class="toggle-group" id="profileGroup">
            <button class="toggle" data-prof="fast">‚ö°</button>
            <button class="toggle active" data-prof="balanced">‚öñÔ∏è</button>
            <button class="toggle" data-prof="stable">üß±</button>
          </span>
        </div>
        <div id="routeInfo" class="route-info">
          <span class="dot-origin">‚óè</span>O
          <span class="dot-dest">‚óè</span>D
          <span class="dot-route">‚îÅ</span>
          <span id="routeText">‚Äì</span>
        </div>
      </div>

    </div>
  </div>

  <div id="toast" class="toast"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    // ---- parametri coezivi dinamici ----
    let COHESION_ALPHA = 1.0;
    let COHESION_BETA  = 1.5;
    let COHESION_GAMMA = 1.2;

    const COHESION_PROFILES = {
      fast:     { alpha: 1.6, beta: 0.8, gamma: 0.8 },
      balanced: { alpha: 1.2, beta: 1.2, gamma: 1.0 },
      stable:   { alpha: 0.9, beta: 1.8, gamma: 1.6 }
    };

    let transportMode = "driving";   // OSRM profile: driving | cycling | walking
    let cohesionProfile = "balanced";

    function applyCohesionProfile() {
      const p = COHESION_PROFILES[cohesionProfile];
      COHESION_ALPHA = p.alpha;
      COHESION_BETA  = p.beta;
      COHESION_GAMMA = p.gamma;
      updateModeChip();
    }

    const map = L.map("map").setView([45.94, 24.97], 5);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19
    }).addTo(map);

    let originLatLng = null;
    let destLatLng   = null;
    let originMarker = null;
    let destMarker   = null;

    let routeLayers = [];
    let bestRouteLayer = null;

    // naviga»õie live
    let navigationActive = false;
    let gpsWatchId = null;
    let userMarker = null;
    let userPrevPoint = null;
    let routeCoords = [];
    let routeSteps = [];
    let currentStepIndex = 0;
    let lastSpokenStepIndex = -1;

    const gpsBtn        = document.getElementById("gpsBtn");
    const fsBtn         = document.getElementById("fsBtn");
    const addressInput  = document.getElementById("addressInput");
    const suggestionsEl = document.getElementById("suggestions");
    const startBtn      = document.getElementById("startBtn");
    const toastEl       = document.getElementById("toast");
    const routeTextEl   = document.getElementById("routeText");
    const navTextEl     = document.getElementById("navText");
    const navDistEl     = document.getElementById("navDist");
    const navArrowEl    = document.querySelector(".nav-arrow");
    const navModeChipEl = document.getElementById("navModeChip");

    const modeGroup = document.getElementById("modeGroup");
    const profileGroup = document.getElementById("profileGroup");

    // icon sƒÉgeatƒÉ
    const arrowIcon = L.divIcon({
      className: "arrow-icon",
      html: "<span>‚ñ≤</span>",
      iconSize: [26, 26],
      iconAnchor: [13, 13]
    });

    function showToast(msg) {
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      setTimeout(() => toastEl.classList.remove("show"), 2500);
    }

    function setOrigin(lat, lon, label) {
      originLatLng = [lat, lon];
      if (originMarker) map.removeLayer(originMarker);
      originMarker = L.marker(originLatLng).addTo(map).bindPopup(label).openPopup();
    }

    function setDest(lat, lon, label) {
      destLatLng = [lat, lon];
      if (destMarker) map.removeLayer(destMarker);
      destMarker = L.marker(destLatLng).addTo(map).bindPopup(label).openPopup();
    }

    function clearRoutes() {
      routeLayers.forEach(r => map.removeLayer(r));
      routeLayers = [];
      if (bestRouteLayer) {
        map.removeLayer(bestRouteLayer);
        bestRouteLayer = null;
      }
      routeCoords = [];
      routeSteps = [];
      currentStepIndex = 0;
      lastSpokenStepIndex = -1;
      routeTextEl.textContent = "‚Äì";
    }

    function getGPSOrigin(showMsg = true) {
      if (!navigator.geolocation) {
        if (showMsg) showToast("Nu existƒÉ GPS pe acest dispozitiv.");
        return;
      }

      navigator.geolocation.getCurrentPosition(
        pos => {
          const lat = pos.coords.latitude;
          const lon = pos.coords.longitude;
          setOrigin(lat, lon, "Origine (GPS)");
          map.setView([lat, lon], 15);
          if (showMsg) showToast("Origine setatƒÉ din GPS.");
        },
        () => showToast("Nu se poate ob»õine GPS.")
      );
    }

    window.onload = () => {
      applyCohesionProfile();
      getGPSOrigin(false);
    };

    gpsBtn.onclick = () => getGPSOrigin(true);

    // FULLSCREEN
    fsBtn.onclick = () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen?.();
      } else {
        document.exitFullscreen?.();
      }
    };

    // click pe hartƒÉ: destina»õie / origine
    map.on("click", e => {
      if (e.originalEvent.altKey) {
        setOrigin(e.latlng.lat, e.latlng.lng, "Origine (Alt+Tap)");
        showToast("Origine setatƒÉ.");
      } else {
        setDest(e.latlng.lat, e.latlng.lng, "Destina»õie");
        showToast("Destina»õie setatƒÉ.");
      }
    });

    // --- toggle mod transport ---
    modeGroup.addEventListener("click", (e) => {
      if (!e.target.dataset.mode) return;
      transportMode = e.target.dataset.mode; // driving | cycling | walking
      [...modeGroup.querySelectorAll(".toggle")].forEach(b => b.classList.toggle("active", b === e.target));
      updateModeChip();
      showToast(transportMode === "driving" ? "Mod: Auto" :
                transportMode === "cycling" ? "Mod: BicicletƒÉ" :
                "Mod: Pe jos");
    });

    // --- toggle profil coeziv ---
    profileGroup.addEventListener("click", (e) => {
      if (!e.target.dataset.prof) return;
      cohesionProfile = e.target.dataset.prof; // fast | balanced | stable
      [...profileGroup.querySelectorAll(".toggle")].forEach(b => b.classList.toggle("active", b === e.target));
      applyCohesionProfile();
      showToast(cohesionProfile === "fast" ? "Profil: Rapid" :
                cohesionProfile === "balanced" ? "Profil: Echilibrat" :
                "Profil: Stabil");
    });

    function updateModeChip() {
      const modeLabel =
        transportMode === "driving" ? "Auto" :
        transportMode === "cycling" ? "Bike" : "Walk";
      const profLabel =
        cohesionProfile === "fast" ? "Rapid" :
        cohesionProfile === "balanced" ? "Echilibrat" : "Stabil";
      navModeChipEl.textContent = `${modeLabel} ¬∑ ${profLabel}`;
    }

    // --- autocomplete Nominatim ---
    let autocompleteTimeout = null;

    addressInput.addEventListener("input", () => {
      const q = addressInput.value.trim();
      destLatLng = null;
      if (q.length < 3) {
        suggestionsEl.style.display = "none";
        return;
      }

      if (autocompleteTimeout) clearTimeout(autocompleteTimeout);
      autocompleteTimeout = setTimeout(() => fetchSuggestions(q), 350);
    });

    async function fetchSuggestions(query) {
      const url = `https://nominatim.openstreetmap.org/search?format=json&limit=5&addressdetails=1&q=${encodeURIComponent(query)}`;
      const res = await fetch(url);
      const data = await res.json();

      suggestionsEl.innerHTML = "";
      if (!data || data.length === 0) {
        suggestionsEl.style.display = "none";
        return;
      }

      data.forEach(item => {
        const div = document.createElement("div");
        div.className = "suggestion-item";
        div.textContent = item.display_name;
        div.onclick = () => chooseSuggestion(item);
        suggestionsEl.appendChild(div);
      });

      suggestionsEl.style.display = "block";
    }

    function chooseSuggestion(item) {
      const lat = parseFloat(item.lat);
      const lon = parseFloat(item.lon);
      setDest(lat, lon, item.display_name);
      map.setView([lat, lon], 15);
      addressInput.value = item.display_name;
      suggestionsEl.style.display = "none";
      showToast("Destina»õie selectatƒÉ.");
    }

    document.addEventListener("click", (e) => {
      const inside =
        e.target === addressInput || suggestionsEl.contains(e.target);
      if (!inside) suggestionsEl.style.display = "none";
    });

    // --- func»õii geo ---
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371000; // m
      const toRad = deg => deg * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 +
                Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                Math.sin(dLon/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function minDistanceToRoute(point, polyline) {
      let minD = Infinity;
      for (const [lat, lon] of polyline) {
        const d = haversine(point[0], point[1], lat, lon);
        if (d < minD) minD = d;
      }
      return minD;
    }

    function bearingDeg(from, to) {
      const [lat1, lon1] = from;
      const [lat2, lon2] = to;
      const toRad = d => d * Math.PI / 180;
      const toDeg = r => r * 180 / Math.PI;

      const œÜ1 = toRad(lat1);
      const œÜ2 = toRad(lat2);
      const Œª1 = toRad(lon1);
      const Œª2 = toRad(lon2);
      const y = Math.sin(Œª2-Œª1)*Math.cos(œÜ2);
      const x = Math.cos(œÜ1)*Math.sin(œÜ2) -
                Math.sin(œÜ1)*Math.cos(œÜ2)*Math.cos(Œª2-Œª1);
      const Œ∏ = Math.atan2(y, x);
      return (toDeg(Œ∏) + 360) % 360;
    }

    // --- text manevre + icon ---
    function maneuverToText(step) {
      if (!step || !step.maneuver) {
        return { text: "UrmeazƒÉ ruta trasatƒÉ.", arrow: "‚¨ÜÔ∏è" };
      }
      const man = step.maneuver;
      const type = man.type || "";
      const mod  = man.modifier || "";
      const name = step.name || "";

      let arrow = "‚¨ÜÔ∏è";
      if (mod === "left") arrow = "‚¨ÖÔ∏è";
      else if (mod === "right") arrow = "‚û°Ô∏è";
      else if (mod === "slight left") arrow = "‚ÜñÔ∏è";
      else if (mod === "slight right") arrow = "‚ÜóÔ∏è";
      else if (type === "roundabout") arrow = "‚≠ï";

      let base = "";
      if (type === "turn") {
        base = mod === "left" ? "VireazƒÉ la st√¢nga" :
               mod === "right" ? "VireazƒÉ la dreapta" :
               "VireazƒÉ";
      } else if (type === "new name" || type === "continue") {
        base = "ContinuƒÉ √Ænainte";
      } else if (type === "roundabout") {
        base = "IntrƒÉ √Æn sensul giratoriu";
      } else if (type === "depart") {
        base = "Porne»ôte pe traseu";
      } else if (type === "arrive") {
        base = "Ai ajuns la destina»õie";
      } else {
        base = "UrmeazƒÉ ruta";
      }

      if (name) base += ` pe ${name}`;
      return { text: base, arrow };
    }

    // --- voce (instruc»õiuni vocale) ---
    function speak(text) {
      if (!("speechSynthesis" in window)) return;
      const utter = new SpeechSynthesisUtterance(text);
      utter.lang = "ro-RO";
      window.speechSynthesis.speak(utter);
    }

    // --- naviga»õie live ---
    function startNavigationTracking() {
      navigationActive = true;
      currentStepIndex = 0;
      lastSpokenStepIndex = -1;

      if (!navigator.geolocation) {
        showToast("Nu existƒÉ GPS pentru naviga»õie live.");
        return;
      }

      if (gpsWatchId !== null) return;

      gpsWatchId = navigator.geolocation.watchPosition(
        pos => {
          const lat = pos.coords.latitude;
          const lon = pos.coords.longitude;
          const point = [lat, lon];

          if (!userMarker) {
            userMarker = L.marker(point, { icon: arrowIcon }).addTo(map);
          } else {
            userMarker.setLatLng(point);
          }

          if (userPrevPoint) {
            const brg = bearingDeg(userPrevPoint, point);
            const el = userMarker.getElement();
            if (el) el.style.transform = `rotate(${brg}deg)`;
          }
          userPrevPoint = point;

          // auto-zoom / follow
          let zoomTarget = 15;
          if (routeSteps.length) {
            const step = routeSteps[Math.min(currentStepIndex, routeSteps.length - 1)];
            const loc = step.maneuver.location; // [lon,lat]
            const dToStep = haversine(point[0], point[1], loc[1], loc[0]);
            if (dToStep > 1500) zoomTarget = 14;
            else if (dToStep > 400) zoomTarget = 15;
            else zoomTarget = 17;
          }
          map.setView(point, Math.max(map.getZoom(), zoomTarget), { animate: true });

          if (!navigationActive || routeCoords.length === 0) return;

          const dRoute = minDistanceToRoute(point, routeCoords);
          const offRouteThreshold =
            transportMode === "walking" ? 60 :
            transportMode === "cycling" ? 100 : 150;

          if (dRoute > offRouteThreshold) {
            showToast("Rerutare...");
            originLatLng = point;
            computeCohesiveRoute(true);
            return;
          }

          updateTurnByTurn(point);
        },
        err => {
          console.error(err);
          showToast("Eroare la GPS live.");
        },
        { enableHighAccuracy: true, maximumAge: 2000, timeout: 10000 }
      );
    }

    function updateTurnByTurn(currentPoint) {
      if (!routeSteps.length) {
        navTextEl.textContent = "UrmeazƒÉ ruta trasatƒÉ.";
        navDistEl.textContent = "";
        return;
      }

      let bestIdx = currentStepIndex;
      let bestD = Infinity;
      for (let i = currentStepIndex; i < Math.min(routeSteps.length, currentStepIndex + 6); i++) {
        const step = routeSteps[i];
        const loc = step.maneuver.location;
        const d = haversine(currentPoint[0], currentPoint[1], loc[1], loc[0]);
        if (d < bestD) {
          bestD = d;
          bestIdx = i;
        }
      }

      currentStepIndex = bestIdx;
      const step = routeSteps[currentStepIndex];
      const { text, arrow } = maneuverToText(step);

      const mLat = step.maneuver.location[1];
      const mLon = step.maneuver.location[0];
      const dToStep = haversine(currentPoint[0], currentPoint[1], mLat, mLon);
      const dShow = dToStep > 1000
        ? `${(dToStep/1000).toFixed(1)} km`
        : `${Math.round(dToStep)} m`;

      navTextEl.textContent = text;
      navArrowEl.textContent = arrow;
      navDistEl.textContent = dToStep < 15 ? "acum" : `√Æn ${dShow}`;

      // voce: c√¢nd se schimbƒÉ step-ul, e»ôti aproape
      if (currentStepIndex !== lastSpokenStepIndex && dToStep < 120) {
        speak(text);
        lastSpokenStepIndex = currentStepIndex;
      }

      if (dToStep < 20 && currentStepIndex < routeSteps.length - 1) {
        currentStepIndex++;
      }
    }

    // --- rutare coezivƒÉ extinsƒÉ ---
    async function computeCohesiveRoute(fromReroute = false) {
      if (!originLatLng) {
        showToast("SeteazƒÉ originea (GPS sau Alt+Tap).");
        return;
      }
      if (!destLatLng) {
        if (!fromReroute) showToast("Alege o destina»õie.");
        return;
      }

      const src = originLatLng;
      const dst = destLatLng;
      const coordsParam = `${src[1]},${src[0]};${dst[1]},${dst[0]}`;
      const profile = transportMode; // driving | cycling | walking

      const url =
        `https://router.project-osrm.org/route/v1/${profile}/${coordsParam}` +
        `?overview=full&geometries=geojson&steps=true&alternatives=true`;

      if (!fromReroute) {
        startBtn.disabled = true;
        startBtn.textContent = "Se calculeazƒÉ...";
      }
      clearRoutes();

      try {
        const res = await fetch(url);
        if (!res.ok) {
          showToast("Eroare la serviciul de rutare.");
          return;
        }

        const data = await res.json();
        if (!data.routes || data.routes.length === 0) {
          showToast("Nicio rutƒÉ gƒÉsitƒÉ.");
          return;
        }

        const routes = data.routes;
        let maxStructural = 0;

        const enriched = routes.map((r) => {
          let maneuvers = 0;
          let microTension = 0;
          const stepsFlat = [];

          r.legs.forEach(leg => {
            maneuvers += leg.steps.length;
            leg.steps.forEach(s => {
              stepsFlat.push(s);
              if (s.maneuver && (s.maneuver.type === "roundabout" || s.maneuver.type === "turn")) {
                microTension += 1.0;
              }
              if (s.distance && s.distance < 40) {
                microTension += 0.5;
              }
            });
          });

          const structuralLoad = maneuvers + microTension;
          if (structuralLoad > maxStructural) maxStructural = structuralLoad;

          return {
            route: r,
            durationSec: r.duration,
            distanceM: r.distance,
            maneuvers,
            microTension,
            structuralLoad,
            stepsFlat
          };
        });

        enriched.forEach(o => {
          o.tensionNorm = maxStructural > 0 ? o.structuralLoad / maxStructural : 0;
          const tMin = o.durationSec / 60;
          o.timeMin = tMin;
          o.cost = COHESION_ALPHA * tMin +
                   COHESION_BETA  * o.maneuvers +
                   COHESION_GAMMA * o.microTension;
        });

        enriched.sort((a, b) => a.cost - b.cost);
        const best = enriched[0];

        routes.forEach(r => {
          const coords = r.geometry.coordinates.map(c => [c[1], c[0]]);
          const pl = L.polyline(coords, { color: "#8e9ba8", weight: 3, opacity: 0.5 }).addTo(map);
          routeLayers.push(pl);
        });

        const bestCoords = best.route.geometry.coordinates.map(c => [c[1], c[0]]);
        bestRouteLayer = L.polyline(bestCoords, { color: "#2563EB", weight: 7 }).addTo(map);

        map.fitBounds(bestRouteLayer.getBounds(), { padding: [50, 180] });

        const km = best.distanceM / 1000.0;
        routeTextEl.textContent =
          `${km.toFixed(1)} km ¬∑ ${best.timeMin.toFixed(0)} min ¬∑ ${best.maneuvers} manevre`;

        routeCoords = bestCoords;
        routeSteps = best.stepsFlat;
        currentStepIndex = 0;
        lastSpokenStepIndex = -1;

        const firstStep = routeSteps[0];
        const { text, arrow } = maneuverToText(firstStep);
        navArrowEl.textContent = arrow;
        navTextEl.textContent = text;
        navDistEl.textContent = "";

        if (!fromReroute) {
          showToast("RutƒÉ coezivƒÉ calculatƒÉ. Naviga»õie pornitƒÉ.");
          startNavigationTracking();
        } else {
          showToast("RutƒÉ coezivƒÉ recalculatƒÉ.");
        }
      } catch (e) {
        console.error(e);
        showToast("Eroare la rutare.");
      } finally {
        if (!fromReroute) {
          startBtn.disabled = false;
          startBtn.textContent = "Start naviga»õie";
        }
      }
    }

    startBtn.addEventListener("click", () => {
      navigationActive = true;
      computeCohesiveRoute(false);
    });
  </script>
</body>
</html>
