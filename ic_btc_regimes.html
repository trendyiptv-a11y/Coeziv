<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8" />
  <title>Regimuri bull & bear – model coeziv BTC</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="Regimuri bull & bear pentru BTCUSDT detectate automat cu modelul coeziv (structură + direcționalitate), pe date zilnice (~2010–prezent)."
  />

  <!-- Luxon + Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>

  <style>
    :root {
      color-scheme: dark;
      --bg: #020617;
      --card: #020617;
      --card-border: rgba(148, 163, 184, 0.35);
      --text-main: #e5e7eb;
      --text-soft: #94a3b8;
      --muted: #64748b;
      --accent: #4f46e5;
      --success: #22c55e;
      --danger: #ef4444;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617 0, #000 55%, #020617 100%);
      color: var(--text-main);
      -webkit-font-smoothing: antialiased;
    }

    .page {
      max-width: 960px;
      margin: 0 auto;
      padding: 1.5rem 1.5rem 3rem;
    }

    header h1 {
      margin: 0 0 0.5rem;
      font-size: 1.6rem;
      letter-spacing: 0.02em;
    }

    header p {
      margin: 0;
      font-size: 0.9rem;
      color: var(--text-soft);
    }

    .pill-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.9rem;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      font-size: 0.8rem;
      color: var(--text-soft);
      background: radial-gradient(circle at top, #020617, #020617);
    }

    .pill-dot {
      width: 0.5rem;
      height: 0.5rem;
      border-radius: 999px;
      background: var(--accent);
    }

    .pill.bull .pill-dot {
      background: var(--success);
    }

    .pill.bear .pill-dot {
      background: var(--danger);
    }

    .back-btn {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      margin-top: 1.2rem;
      margin-bottom: 0.6rem;
      font-size: 0.8rem;
      padding: 0.45rem 0.9rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-main);
      text-decoration: none;
    }

    .back-btn span.icon {
      font-size: 1rem;
    }

    /* SWITCH mod conservator / practic */
    .mode-toggle {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin: 1.2rem 0 1rem;
    }

    .mode-btn {
      flex: 1 1 150px;
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-soft);
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      cursor: pointer;
      transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
    }

    .mode-btn.active {
      background: linear-gradient(135deg, #3b82f6, #22c55e);
      border-color: transparent;
      color: #020617;
      font-weight: 600;
    }

    .mode-btn span.sub {
      display: block;
      font-size: 0.7rem;
      text-transform: none;
      letter-spacing: normal;
      opacity: 0.9;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 0.9rem;
      margin-bottom: 1.2rem;
    }

    @media (max-width: 720px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }

    .card {
      border-radius: 1rem;
      padding: 0.9rem 1rem;
      background: radial-gradient(circle at top, #020617, #020617);
      border: 1px solid var(--card-border);
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.85);
    }

    .card-title {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      margin-bottom: 0.35rem;
    }

    .card-value {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 0.2rem;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      padding: 0.18rem 0.7rem;
      border-radius: 999px;
      font-size: 0.72rem;
      border: 1px solid rgba(148, 163, 184, 0.35);
      color: var(--text-soft);
    }

    .badge.bull {
      border-color: rgba(34, 197, 94, 0.7);
      color: #bbf7d0;
      background: rgba(22, 163, 74, 0.14);
    }

    .badge.bear {
      border-color: rgba(239, 68, 68, 0.7);
      color: #fecaca;
      background: rgba(239, 68, 68, 0.13);
    }

    .card small {
      display: block;
      font-size: 0.75rem;
      color: var(--text-soft);
      margin-top: 0.25rem;
    }

    .current-regime-card {
      grid-column: 1 / -1;
    }

    .current-regime-value {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.4rem 1.1rem;
      border-radius: 999px;
      font-size: 1.3rem;
      font-weight: 600;
      margin-bottom: 0.25rem;
    }

    .current-regime-value.current-bull {
      background: rgba(34, 197, 94, 0.18);
      color: #bbf7d0;
      box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.4);
    }

    .current-regime-value.current-bear {
      background: rgba(239, 68, 68, 0.18);
      color: #fecaca;
      box-shadow: 0 0 0 1px rgba(239, 68, 68, 0.4);
    }

    .current-regime-value.current-neutral {
      background: rgba(148, 163, 184, 0.18);
      color: #e5e7eb;
      box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.4);
    }

    .current-regime-meta {
      font-size: 0.78rem;
      color: var(--text-soft);
    }

    .chart-card {
      margin-top: 0.6rem;
      margin-bottom: 1.3rem;
    }

    .chart-title {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 0.25rem;
    }

    .chart-sub {
      font-size: 0.8rem;
      color: var(--text-soft);
      margin-bottom: 0.7rem;
    }

    .chart-wrapper {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9;
      border-radius: 1.5rem;
      border: 1px solid var(--card-border);
      background: radial-gradient(circle at top, #020617, #020617);
      box-shadow: 0 18px 45px rgba(15, 23, 42, 0.85);
      padding: 0.75rem 0.8rem 0.8rem;
      overflow: hidden;
    }

    .chart-wrapper canvas {
      position: absolute;
      inset: 0;
      width: 100% !important;
      height: 100% !important;
    }

    .legend-inline {
      position: relative;
      z-index: 2;
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
      align-items: center;
      font-size: 0.8rem;
      color: var(--text-soft);
      margin-bottom: 0.4rem;
    }

    .legend-color {
      width: 0.9rem;
      height: 0.4rem;
      border-radius: 999px;
    }

    .legend-color.price {
      background: rgba(56, 189, 248, 0.9);
    }

    .legend-color.bull {
      background: rgba(34, 197, 94, 0.7);
    }

    .legend-color.bear {
      background: rgba(239, 68, 68, 0.7);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.6rem;
      font-size: 0.8rem;
    }

    th,
    td {
      padding: 0.45rem 0.55rem;
      text-align: left;
    }

    thead tr {
      background: rgba(15, 23, 42, 0.95);
    }

    th {
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--muted);
      border-bottom: 1px solid rgba(51, 65, 85, 0.9);
    }

    tbody tr:nth-child(odd) {
      background: rgba(15, 23, 42, 0.5);
    }

    tbody tr:nth-child(even) {
      background: rgba(15, 23, 42, 0.8);
    }

    td {
      border-bottom: 1px solid rgba(30, 41, 59, 0.75);
      color: #e5e7eb;
    }

    .tag-dot {
      width: 0.55rem;
      height: 0.55rem;
      border-radius: 999px;
      margin-right: 0.35rem;
      display: inline-block;
    }

    .tag-dot.bull {
      background: #22c55e;
    }

    .tag-dot.bear {
      background: #ef4444;
    }

    .note {
      margin-top: 0.9rem;
      font-size: 0.8rem;
      color: var(--text-soft);
      line-height: 1.5;
    }

    .note strong {
      color: #e5e7eb;
      font-weight: 500;
    }
  </style>
</head>
<body>
  <main class="page">
    <header>
      <h1>Regimuri bull &amp; bear – model coeziv BTC</h1>
      <p>
        Perioade de bull market și bear market estimate automat din indicii
        coezivi IC_BTC structural și ICD_BTC direcțional, calculați pe date
        zilnice BTCUSDT (~2010–prezent).
      </p>

      <div class="pill-row">
        <div class="pill">
          <span class="pill-dot"></span>
          <span>Model coeziv – structură &amp; direcționalitate, praguri adaptate la date</span>
        </div>
        <div class="pill bull">
          <span class="pill-dot"></span>
          <span>Bull: structură puternică + mișcări aliniate trendului</span>
        </div>
        <div class="pill bear">
          <span class="pill-dot"></span>
          <span>Bear: structură puternică + mișcări contra trendului</span>
        </div>
      </div>

      <a href="ic_btc.html" class="back-btn">
        <span class="icon">←</span>
        <span>Înapoi la indice IC_BTC</span>
      </a>
    </header>

    <!-- Switch mod -->
    <div class="mode-toggle">
      <button id="modeConservative" class="mode-btn active">
        Conservator
        <span class="sub">regimuri clare, filtrate</span>
      </button>
      <button id="modePractical" class="mode-btn">
        Practic (trader)
        <span class="sub">prelungește ultimul bull / bear dacă trendul continuă</span>
      </button>
    </div>

    <!-- Statistici -->
    <section class="grid">
      <article class="card">
        <div class="card-title">Număr regimuri bull detectate</div>
        <div class="card-value" id="bullCount">0</div>
        <span class="badge bull">bull</span>
        <small>Perioade în care structura este ridicată, iar direcționalitatea
          favorizează trendul principal (durată minimă ≈ 20 zile).</small>
      </article>

      <article class="card">
        <div class="card-title">Număr regimuri bear detectate</div>
        <div class="card-value" id="bearCount">0</div>
        <span class="badge bear">bear</span>
        <small>Perioade în care structura rămâne ridicată, dar direcționalitatea
          este inversă față de trendul dominant (presiune descendentă).</small>
      </article>

      <article class="card">
        <div class="card-title">Cel mai lung bull (zile)</div>
        <div class="card-value" id="longestBull">–</div>
        <small>Durata aproximativă a celui mai lung regim bull detectat.</small>
      </article>

      <article class="card">
        <div class="card-title">Cel mai lung bear (zile)</div>
        <div class="card-value" id="longestBear">–</div>
        <small>Durata aproximativă a celui mai lung regim bear detectat.</small>
      </article>

      <article class="card current-regime-card">
        <div class="card-title">Regim curent (model coeziv)</div>
        <div id="currentRegimeValue" class="current-regime-value current-neutral">-</div>
        <div id="currentRegimeMeta" class="current-regime-meta">
          Se calculează automat din indicii IC_BTC structural și ICD_BTC direcțional pentru ultima zi din serie.
        </div>
      </article>
    </section>

    <!-- Grafic -->
    <section class="card chart-card">
      <div class="chart-title">Regimuri bull &amp; bear pe preț BTC</div>
      <div class="chart-sub">
        Fundal verde = bull market, fundal roșu = bear market. Linia albastră reprezintă prețul BTCUSDT (close, timeframe 1D).
        Regimurile se pot vizualiza în modul conservator sau practic.
      </div>

      <div class="chart-wrapper">
        <div class="legend-inline">
          <span class="legend-color price"></span> BTCUSDT close (1D)
          <span class="legend-color bull"></span> bull market
          <span class="legend-color bear"></span> bear market
        </div>
        <canvas id="regimeChart"></canvas>
      </div>
    </section>

    <!-- Tabel -->
    <section class="card">
      <div class="chart-title">Perioade bull &amp; bear detectate</div>
      <div class="chart-sub">
        Lista intervalelor detectate de modelul coeziv pentru modul selectat (conservator / practic).
      </div>

      <table>
        <thead>
          <tr>
            <th>Tip</th>
            <th>Început</th>
            <th>Sfârșit</th>
            <th>Durată (zile)</th>
          </tr>
        </thead>
        <tbody id="regimeTableBody">
          <tr>
            <td colspan="4">Se încarcă datele...</td>
          </tr>
        </tbody>
      </table>

      <p class="note">
        <strong>Mod conservator</strong>: detectează doar regimuri cu structură și direcționalitate foarte clare (mai puține, dar robuste).<br/>
        <strong>Mod practic (trader)</strong>: pornește de la aceleași regimuri și prelungește ultimul bull / bear dacă indicii coezivi sugerează continuarea trendului.
        Nu reprezintă recomandare financiară.
      </p>
    </section>
  </main>

  <script>
    const DateTime = luxon.DateTime;

    // globale pentru moduri
    let regimesConservative = [];
    let regimesPractical = [];
    let timestampsGlobal = [];
    let priceChart = null;
    let currentMode = "conservative";

    const MS_PER_DAY = 1000 * 60 * 60 * 24;

    // ---------- helpers numeric ----------
    function ema(values, period) {
      const out = new Array(values.length).fill(null);
      if (!values.length) return out;
      const k = 2 / (period + 1);
      let prev = values[0] ?? 0;
      out[0] = prev;
      for (let i = 1; i < values.length; i++) {
        const v = values[i] ?? prev;
        prev = v * k + prev * (1 - k);
        out[i] = prev;
      }
      return out;
    }

    function rollingMean(values, window) {
      const n = values.length;
      const out = new Array(n).fill(null);
      let sum = 0;
      let count = 0;
      for (let i = 0; i < n; i++) {
        const v = values[i];
        if (Number.isFinite(v)) {
          sum += v;
          count++;
        }
        if (i >= window) {
          const old = values[i - window];
          if (Number.isFinite(old)) {
            sum -= old;
            count--;
          }
        }
        if (i >= window - 1 && count > 0) {
          out[i] = sum / count;
        }
      }
      return out;
    }

    function quantile(arr, p) {
      const vals = arr.filter(v => Number.isFinite(v)).slice().sort((a, b) => a - b);
      if (!vals.length) return NaN;
      const idx = (vals.length - 1) * p;
      const lo = Math.floor(idx);
      const hi = Math.ceil(idx);
      if (lo === hi) return vals[lo];
      const w = idx - lo;
      return vals[lo] * (1 - w) + vals[hi] * w;
    }

    function clamp(v, min, max) {
      return Math.min(max, Math.max(min, v));
    }

    // ---------- Indici coezivi ----------
    function computeCohesiveIndices(closes, timestamps) {
      const n = closes.length;
      if (!n) return { icStruct: [], icDir: [] };

      const returns = new Array(n).fill(0);
      for (let i = 1; i < n; i++) {
        const cPrev = closes[i - 1];
        const cNow = closes[i];
        if (cPrev > 0 && cNow > 0) {
          returns[i] = Math.log(cNow / cPrev) * 100;
        } else {
          returns[i] = 0;
        }
      }

      const absReturns = returns.map(v => Math.abs(v));

      const ema50 = ema(closes, 50);
      const ema200 = ema(closes, 200);
      const trendStrength = ema50.map((v, i) =>
        v != null && ema200[i] != null ? v - ema200[i] : null
      );

      const vol30 = rollingMean(absReturns, 30);

      const rawStruct = trendStrength.map((t, i) => {
        const vol = vol30[i];
        if (t == null || vol == null || vol <= 0) return null;
        return Math.abs(t) / (vol + 1e-6);
      });

      const scaleStruct = quantile(rawStruct, 0.9) || 1;
      const icStruct = rawStruct.map(v =>
        v == null ? null : clamp((v / scaleStruct) * 100, 0, 100)
      );

      const meanRet30 = rollingMean(returns, 30);
      const meanAbs30 = rollingMean(absReturns, 30);

      const icDir = meanRet30.map((m, i) => {
        const ma = meanAbs30[i];
        if (m == null || ma == null || ma <= 0) return null;
        const ratio = m / ma; // [-1,1] aproximativ
        const val = 50 * (1 + ratio); // [0,100]
        return clamp(val, 0, 100);
      });

      return { icStruct, icDir };
    }

    // ---------- detectare regimuri (conservator) ----------
    function detectRegimes(icStruct, icDir, timestamps) {
      const n = icStruct.length;
      const regimes = [];
      if (!n) return regimes;

      const structVals = icStruct.filter(v => Number.isFinite(v));
      const dirVals = icDir.filter(v => Number.isFinite(v));
      if (!structVals.length || !dirVals.length) return regimes;

      const structHigh = quantile(structVals, 0.6);
      const dirHigh = quantile(dirVals, 0.6);
      const dirLow = quantile(dirVals, 0.4);
      const MIN_DAYS = 20;

      const labels = new Array(n).fill(null);
      for (let i = 0; i < n; i++) {
        const s = icStruct[i];
        const d = icDir[i];
        if (!Number.isFinite(s) || !Number.isFinite(d)) continue;

        if (s >= structHigh && d >= dirHigh) {
          labels[i] = "bull";
        } else if (s >= structHigh && d <= dirLow) {
          labels[i] = "bear";
        }
      }

      let currentType = null;
      let startIndex = null;

      for (let i = 0; i < n; i++) {
        const label = labels[i];
        if (label === currentType) continue;

        // s-a schimbat regimul
        if (currentType && startIndex != null) {
          const endIndex = i - 1;
          const startTs = timestamps[startIndex];
          const endTs = timestamps[endIndex];
          if (startTs != null && endTs != null) {
            const days = (endTs - startTs) / MS_PER_DAY;
            if (days >= MIN_DAYS) {
              regimes.push({
                type: currentType,
                startIndex,
                endIndex,
                start: startTs,
                end: endTs,
                durationDays: Math.round(days),
              });
            }
          }
        }

        currentType = label;
        startIndex = label ? i : null;
      }

      // închidem regimul care a rămas deschis până la capăt
      if (currentType && startIndex != null) {
        const endIndex = n - 1;
        const startTs = timestamps[startIndex];
        const endTs = timestamps[endIndex];
        if (startTs != null && endTs != null) {
          const days = (endTs - startTs) / MS_PER_DAY;
          if (days >= MIN_DAYS) {
            regimes.push({
              type: currentType,
              startIndex,
              endIndex,
              start: startTs,
              end: endTs,
              durationDays: Math.round(days),
            });
          }
        }
      }

      return regimes;
    }

    // ---------- derivare regimuri "practice" ----------
    function derivePracticalRegimes(regimes, icStruct, icDir, timestamps) {
      if (!regimes || !regimes.length || !timestamps.length) return [];

      const practical = regimes.map(r => ({ ...r }));
      const n = timestamps.length;
      const lastTs = timestamps[n - 1];

      const last = practical[practical.length - 1];
      if (!last) return practical;

      // dacă deja ajunge la final, nu facem nimic
      if (last.end >= lastTs) return practical;

      // analizăm ultimele ~40 zile după end
      let endIndex = last.endIndex ?? null;
      if (endIndex == null) {
        for (let i = n - 1; i >= 0; i--) {
          if (timestamps[i] === last.end) {
            endIndex = i;
            break;
          }
        }
        if (endIndex == null) endIndex = n - 1;
      }

      const tailStart = Math.min(n - 1, endIndex + 1);
      if (tailStart >= n) return practical;

      const lookbackStart = Math.max(tailStart, n - 40);

      let sumStruct = 0;
      let sumDir = 0;
      let count = 0;

      for (let i = lookbackStart; i < n; i++) {
        const s = icStruct[i];
        const d = icDir[i];
        if (!Number.isFinite(s) || !Number.isFinite(d)) continue;
        sumStruct += s;
        sumDir += d;
        count++;
      }

      if (!count) return practical;

      const avgStruct = sumStruct / count;
      const avgDir = sumDir / count;

      const minStruct = 35; // mai permisiv
      const bullDir = 55;
      const bearDir = 45;

      if (last.type === "bull") {
        if (avgStruct >= minStruct && avgDir >= bullDir) {
          last.end = lastTs;
          last.endIndex = n - 1;
          last.durationDays = Math.round((last.end - last.start) / MS_PER_DAY);
        }
      } else if (last.type === "bear") {
        if (avgStruct >= minStruct && avgDir <= bearDir) {
          last.end = lastTs;
          last.endIndex = n - 1;
          last.durationDays = Math.round((last.end - last.start) / MS_PER_DAY);
        }
      }

      return practical;
    }

    // ---------- plugin fundal bull/bear ----------
    const regimeBackgroundPlugin = {
      id: "regimeBackground",
      beforeDraw(chart, args, opts) {
        const regimes = opts && opts.regimes;
        if (!regimes || !regimes.length) return;
        const { ctx, chartArea, scales } = chart;
        const xScale = scales.x;
        if (!xScale) return;

        ctx.save();
        for (const r of regimes) {
          const xStart = xScale.getPixelForValue(r.start);
          const xEnd = xScale.getPixelForValue(r.end);
          if (!Number.isFinite(xStart) || !Number.isFinite(xEnd)) continue;
          const width = xEnd - xStart;
          if (!Number.isFinite(width) || width <= 0) continue;

          ctx.fillStyle =
            r.type === "bull"
              ? "rgba(34,197,94,0.10)"
              : "rgba(239,68,68,0.10)";
          ctx.fillRect(
            xStart,
            chartArea.top,
            width,
            chartArea.bottom - chartArea.top
          );
        }
        ctx.restore();
      },
    };

    Chart.register(regimeBackgroundPlugin);

    // ---------- UI helpers ----------
    function updateStats(regimes) {
      const bullCount = regimes.filter(r => r.type === "bull").length;
      const bearCount = regimes.filter(r => r.type === "bear").length;

      document.getElementById("bullCount").textContent = bullCount.toString();
      document.getElementById("bearCount").textContent = bearCount.toString();

      const longestBull = regimes
        .filter(r => r.type === "bull")
        .reduce((max, r) => Math.max(max, r.durationDays), 0);
      const longestBear = regimes
        .filter(r => r.type === "bear")
        .reduce((max, r) => Math.max(max, r.durationDays), 0);

      document.getElementById("longestBull").textContent =
        longestBull > 0 ? longestBull.toString() : "–";
      document.getElementById("longestBear").textContent =
        longestBear > 0 ? longestBear.toString() : "–";
    }

    function formatDate(ts) {
      return DateTime.fromMillis(ts).toFormat("yyyy-LL-dd");
    }

    function updateTable(regimes) {
      const tbody = document.getElementById("regimeTableBody");
      tbody.innerHTML = "";

      if (!regimes.length) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = 4;
        td.textContent =
          "Nu au fost detectate regimuri bull / bear pentru pragurile curente.";
        tr.appendChild(td);
        tbody.appendChild(tr);
        return;
      }

      regimes.forEach(r => {
        const tr = document.createElement("tr");

        const tdType = document.createElement("td");
        const dot = document.createElement("span");
        dot.className = "tag-dot " + r.type;
        tdType.appendChild(dot);
        tdType.appendChild(
          document.createTextNode(r.type === "bull" ? "bull market" : "bear market")
        );
        tr.appendChild(tdType);

        const tdStart = document.createElement("td");
        tdStart.textContent = formatDate(r.start);
        tr.appendChild(tdStart);

        const tdEnd = document.createElement("td");
        tdEnd.textContent = formatDate(r.end);
        tr.appendChild(tdEnd);

        const tdDur = document.createElement("td");
        tdDur.textContent = r.durationDays.toString();
        tr.appendChild(tdDur);

        tbody.appendChild(tr);
      });
    }

    function updateCurrentRegime(regimes, timestamps) {
      const labelEl = document.getElementById("currentRegimeValue");
      const metaEl = document.getElementById("currentRegimeMeta");
      if (!labelEl || !metaEl) return;

      if (!regimes.length || !timestamps.length) {
        labelEl.textContent = "-";
        labelEl.className = "current-regime-value current-neutral";
        metaEl.textContent =
          "Nu există suficiente date pentru determinarea regimului curent.";
        return;
      }

      const lastTs = timestamps[timestamps.length - 1];
      const lastDate = DateTime.fromMillis(lastTs).toISODate();

      const current = regimes.find(
        r => lastTs >= r.start && lastTs <= r.end
      );

      if (!current) {
        labelEl.textContent = "neutru";
        labelEl.className = "current-regime-value current-neutral";
        metaEl.textContent =
          `Ultima dată (${lastDate}) nu se încadrează într-un regim bull / bear clar după modelul coeziv.`;
        return;
      }

      const start = DateTime.fromMillis(current.start).toISODate();
      const end = DateTime.fromMillis(current.end).toISODate();
      const days = current.durationDays;

      if (current.type === "bull") {
        labelEl.textContent = "bull market";
        labelEl.className = "current-regime-value current-bull";
        metaEl.textContent =
          `Regim bull estimat de la ${start} până la ${end === lastDate ? "prezent" : end} (~${days} zile).`;
      } else {
        labelEl.textContent = "bear market";
        labelEl.className = "current-regime-value current-bear";
        metaEl.textContent =
          `Regim bear estimat de la ${start} până la ${end === lastDate ? "prezent" : end} (~${days} zile).`;
      }
    }

    function renderForMode(mode) {
      const regimes =
        mode === "practical" ? regimesPractical : regimesConservative;

      updateStats(regimes);
      updateTable(regimes);
      updateCurrentRegime(regimes, timestampsGlobal);

      if (priceChart) {
        priceChart.options.plugins.regimeBackground.regimes = regimes;
        priceChart.update();
      }
    }

    // ---------- init ----------
    async function init() {
      try {
        const resp = await fetch("btc_ohlc.json?ts=" + Date.now(), {
          cache: "no-store",
        });
        if (!resp.ok) throw new Error("Nu pot încărca btc_ohlc.json");
        const raw = await resp.json();

        const points = raw
          .map(row => {
            const t = row.timestamp ?? row.time ?? row.t;
            const c = row.close ?? row.c;
            if (t == null || c == null) return null;
            return { t: Number(t), c: Number(c) };
          })
          .filter(p => p && Number.isFinite(p.t) && Number.isFinite(p.c))
          .sort((a, b) => a.t - b.t);

        if (!points.length) {
          console.error("btc_ohlc.json nu conține puncte valide");
          return;
        }

        const timestamps = points.map(p => p.t);
        const closes = points.map(p => p.c);
        timestampsGlobal = timestamps;

        const { icStruct, icDir } = computeCohesiveIndices(closes, timestamps);

        regimesConservative = detectRegimes(icStruct, icDir, timestamps);
        regimesPractical = derivePracticalRegimes(
          regimesConservative,
          icStruct,
          icDir,
          timestamps
        );

        const ctx = document.getElementById("regimeChart");
        const chartData = points.map(p => ({ x: p.t, y: p.c }));

        priceChart = new Chart(ctx, {
          type: "line",
          data: {
            datasets: [
              {
                label: "BTCUSDT close (1D)",
                data: chartData,
                borderColor: "rgba(56,189,248,1)",
                borderWidth: 1.4,
                pointRadius: 0,
                pointHitRadius: 6,
                tension: 0.08,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: "index",
              intersect: false,
            },
            plugins: {
              legend: {
                display: false,
              },
              tooltip: {
                callbacks: {
                  title(items) {
                    if (!items.length) return "";
                    const ts = items[0].parsed.x;
                    return DateTime.fromMillis(ts).toFormat("dd LLL yyyy");
                  },
                  label(ctx) {
                    const v = ctx.parsed.y;
                    if (!Number.isFinite(v)) return "";
                    return (
                      " BTCUSDT close: " +
                      v.toLocaleString("en-US", {
                        maximumFractionDigits: 2,
                      })
                    );
                  },
                },
              },
              regimeBackground: {
                regimes: regimesConservative,
              },
            },
            scales: {
              x: {
                type: "time",
                time: { unit: "year" },
                ticks: {
                  maxRotation: 0,
                  autoSkipPadding: 24,
                  color: "rgba(148,163,184,0.9)",
                  font: { size: 11 },
                },
                grid: {
                  color: "rgba(30,64,175,0.18)",
                },
              },
              y: {
                ticks: {
                  color: "rgba(148,163,184,0.9)",
                  callback(value) {
                    if (!Number.isFinite(value)) return "";
                    return value.toLocaleString("en-US", {
                      maximumFractionDigits: 0,
                    });
                  },
                },
                grid: {
                  color: "rgba(30,64,175,0.15)",
                },
              },
            },
          },
        });

        // butoane mod
        const btnCons = document.getElementById("modeConservative");
        const btnPract = document.getElementById("modePractical");

        if (btnCons && btnPract) {
          btnCons.addEventListener("click", () => {
            currentMode = "conservative";
            btnCons.classList.add("active");
            btnPract.classList.remove("active");
            renderForMode(currentMode);
          });

          btnPract.addEventListener("click", () => {
            currentMode = "practical";
            btnPract.classList.add("active");
            btnCons.classList.remove("active");
            renderForMode(currentMode);
          });
        }

        // rand inițial (conservator)
        renderForMode(currentMode);
      } catch (err) {
        console.error("Eroare la inițializarea paginii bull/bear:", err);
      }
    }

    init();
  </script>
</body>
</html>
