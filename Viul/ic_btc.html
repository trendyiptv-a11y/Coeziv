<!DOCTYPE html>
<html lang="ro">
<head>
<meta charset="UTF-8">
<title>Indice Coeziv Bitcoin – Gratuit, Live</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
body {
  background: #0b0d11;
  color: #e5e7eb;
  font-family: system-ui, sans-serif;
  padding: 1rem;
}
.card {
  background: #11141b;
  padding: 1rem;
  margin-bottom: 1rem;
  border-radius: 10px;
}
button {
  width: 100%;
  padding: 0.7rem;
  background: #2563eb;
  color: white;
  border: none;
  border-radius: 8px;
  font-weight: 600;
}
canvas {
  margin-top: 1rem;
}
</style>
</head>
<body>

<h2>Indice Coeziv Bitcoin – LIVE & GRATUIT</h2>
<p>Fără chei, fără conturi. Datele vin din Binance prin AllOrigins.</p>

<div class="card">
  <button id="loadBtn">Încarcă date BTC & calculează IC</button>
  <p id="status"></p>
</div>

<div class="card">
  <canvas id="chart" height="280"></canvas>
  <p id="lastVal"></p>
</div>

<script>
// ---------------- UTILITARE ----------------
function ema(vals, len) {
  let k = 2 / (len + 1);
  let ema = null;
  return vals.map(v => {
    if (ema === null) ema = v;
    else ema = v * k + ema * (1 - k);
    return ema;
  });
}

function rollingMean(arr, len) {
  let out = [];
  for (let i = 0; i < arr.length; i++) {
    if (i < len) { out.push(null); continue; }
    let slice = arr.slice(i - len, i);
    out.push(slice.reduce((a,b)=>a+b,0)/len);
  }
  return out;
}

function rollingStd(arr, len) {
  let out = [];
  for (let i = 0; i < arr.length; i++) {
    if (i < len) { out.push(null); continue; }
    let slice = arr.slice(i - len, i).filter(v=>v!=null);
    let m = slice.reduce((a,b)=>a+b,0)/slice.length;
    let v = slice.reduce((s,x)=>s+(x-m)**2,0)/slice.length;
    out.push(Math.sqrt(v));
  }
  return out;
}

// ---------------- CALCUL IC ----------------
function computeIC(close, volume) {
  const p = {
    lenTrend: 200,
    lenShort: 60,
    lenVol: 30,
    lenATR: 20,
    lenFlux: 40,
    smooth: 10,
    alpha: 0.65,
    beta: 0.35
  };

  let open = close.map((c,i)=> i===0 ? c : close[i-1]);

  let emaLong  = ema(close, p.lenTrend);
  let emaShort = ema(close, p.lenShort);

  let trend = emaShort.map((v,i)=> Math.min(Math.abs(v-emaLong[i])/emaLong[i]/0.1, 1));

  let ret = close.map((c,i)=> i===0?0:c-close[i-1]);
  let pos = ret.map(v=> v>0?v:0);
  let neg = ret.map(v=> v<0?-v:0);
  let dirPos = ema(pos, p.lenShort);
  let dirNeg = ema(neg, p.lenShort);
  let clean = dirPos.map((v,i)=> Math.abs(v/(v+dirNeg[i]+1e-9)-0.5)*2);

  let C_core = trend.map((v,i)=> 0.7*v+0.3*clean[i]);

  let volMA = rollingMean(volume, p.lenVol);
  let volRel = volume.map((v,i)=> volMA[i]? Math.min(v/volMA[i],4)/4 : null);

  let isUp = close.map((c,i)=> c>open[i]);
  let volUp = volume.map((v,i)=> isUp[i]?v:0);
  let volDn = volume.map((v,i)=> isUp[i]?0:v);
  let volUpMA = rollingMean(volUp,p.lenVol);
  let volDnMA = rollingMean(volDn,p.lenVol);

  let volQuality = volUpMA.map((v,i)=> v? v/(v+(volDnMA[i]||0)+1e-9):null);

  // ATR aproximat (folosim |close-close_prev|)
  let tr = ret.map(v=>Math.abs(v));
  let ATR = ema(tr, p.lenATR);
  let atrRel = ATR.map((v,i)=> v/close[i]);

  let atrHealthy = atrRel.map(v=> 1 - Math.abs(Math.min(v,0.16)/0.08 -1));

  let C_eco = volRel.map((v,i)=> v && volQuality[i] && atrHealthy[i]
      ? 0.4*v+0.4*volQuality[i]+0.2*atrHealthy[i]
      : null);

  let C_core_std = rollingStd(C_core,p.lenFlux);
  let C_eco_std  = rollingStd(C_eco,p.lenFlux);
  let atr_std    = rollingStd(atrRel,p.lenFlux);

  let flux = C_core_std.map((v,i)=> v&&C_eco_std[i]&&atr_std[i]
      ? Math.min((v+C_eco_std[i]+atr_std[i])/0.03,1)
      : null);

  let C_struct = C_core.map((v,i)=> v&&C_eco[i] ? p.alpha*v+(1-p.alpha)*C_eco[i] : null);

  let raw = C_struct.map((v,i)=> v&&flux[i]? v - p.beta*flux[i] : null);

  let clipped = raw.map(v=> v==null?null:Math.max(0,Math.min(1,v)));

  let ic_raw = clipped.map(v=> v==null?null:v*100);

  return ema(ic_raw,p.smooth);
}

// ---------------- Fetch BTC from Binance (no key) ----------------
async function fetchBinanceDaily() {
  const url = "https://api.allorigins.win/raw?url=" +
    encodeURIComponent("https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1d&limit=1000");

  const res = await fetch(url);
  return await res.json();
}

// ---------------- Render ----------------
const btn = document.getElementById("loadBtn");
const statusEl = document.getElementById("status");
const lastValEl = document.getElementById("lastVal");
const ctx = document.getElementById("chart").getContext("2d");
let chart = null;

btn.onclick = async () => {
  statusEl.textContent = "Încarc date...";
  btn.disabled = true;

  try {
    const data = await fetchBinanceDaily();
    const close = data.map(c => parseFloat(c[4]));
    const volume = data.map(c => parseFloat(c[5]));
    const dates = data.map(c => new Date(c[0]).toISOString().slice(0,10));

    statusEl.textContent = "Calculez indicele...";
    const ic = computeIC(close, volume);

    if (chart) chart.destroy();
    chart = new Chart(ctx, {
      type: "line",
      data: {
        labels: dates,
        datasets: [{
          data: ic,
          label: "IC_BTC (0–100)",
          borderColor: "#f8fafc",
          borderWidth: 1.5,
          pointRadius: 0,
          tension: 0.15
        }]
      },
      options: {
        scales: {
          y: { min:0, max:100 }
        }
      }
    });

    let last = ic[ic.length-1].toFixed(2);
    lastValEl.textContent = "Ultima valoare IC_BTC: " + last;
    statusEl.textContent = "Gata.";
  } catch (e) {
    statusEl.textContent = "Eroare: " + e.message;
  } finally {
    btn.disabled = false;
  }
};
</script>

</body>
</html>
