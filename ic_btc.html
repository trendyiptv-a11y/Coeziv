<script>
  // ----------------- UTILITARE NUMERICE -----------------

  function ema(values, len) {
    const k = 2 / (len + 1);
    const out = new Array(values.length).fill(null);
    let prev = null;
    for (let i = 0; i < values.length; i++) {
      const v = values[i];
      if (v == null || !isFinite(v)) {
        out[i] = prev;
        continue;
      }
      if (prev === null) {
        prev = v;
      } else {
        prev = v * k + prev * (1 - k);
      }
      out[i] = prev;
    }
    return out;
  }

  function computeATR(candles, len) {
    const tr = new Array(candles.length).fill(null);
    for (let i = 0; i < candles.length; i++) {
      const h = candles[i].high;
      const l = candles[i].low;
      if (i === 0) {
        tr[i] = h - l;
      } else {
        const prevClose = candles[i - 1].close;
        const tr1 = h - l;
        const tr2 = Math.abs(h - prevClose);
        const tr3 = Math.abs(l - prevClose);
        tr[i] = Math.max(tr1, tr2, tr3);
      }
    }
    return ema(tr, len);
  }

  function normalize01(arr) {
    let max = -Infinity;
    for (const v of arr) {
      if (v != null && isFinite(v) && v > max) max = v;
    }
    if (!isFinite(max) || max <= 0) {
      return arr.map(() => 0);
    }
    return arr.map((v) =>
      v == null || !isFinite(v) ? 0 : Math.min(1, Math.max(0, v / max))
    );
  }

  function lastNonNull(arr) {
    for (let i = arr.length - 1; i >= 0; i--) {
      if (arr[i] != null && isFinite(arr[i])) return arr[i];
    }
    return null;
  }

  // ----------------- FETCH BTC OHLC -----------------

  async function fetchBTC() {
    const url = "btc_ohlc.json"; // ic_btc.html și btc_ohlc.json sunt în același folder
    const res = await fetch(url);
    if (!res.ok) {
      throw new Error("Nu pot încărca btc_ohlc.json (" + res.status + ")");
    }
    const data = await res.json();
    if (!Array.isArray(data)) {
      throw new Error("Format invalid în btc_ohlc.json");
    }

    // Așteptăm [{timestamp, open, high, low, close, volume}]
    return data.map((d) => ({
      timestamp: d.timestamp,
      open: Number(d.open),
      high: Number(d.high),
      low: Number(d.low),
      close: Number(d.close),
    }));
  }

  // ----------------- IC_BTC STRUCTURAL (ce aveai deja) -----------------

  function calcIndiceCoezivStructural(candles) {
    if (!candles || candles.length === 0) return [];

    const closes = candles.map((c) => c.close);

    const coreLen = 30;
    const lenFlux = 14;
    const smoothLen = 10;
    const beta = 0.6;

    const emaFast = ema(closes, coreLen);
    const emaSlow = ema(closes, coreLen * 2);

    const trendStrength = closes.map((c, i) => {
      const ef = emaFast[i];
      const es = emaSlow[i];
      if (c == null || !isFinite(c) || ef == null || es == null) return null;
      return Math.abs(ef - es) / c;
    });

    const atr = computeATR(candles, lenFlux);
    const relVol = atr.map((v, i) => {
      const c = closes[i];
      if (v == null || !isFinite(v) || c == null || !isFinite(c)) return null;
      return v / c;
    });

    const C_struct = normalize01(trendStrength);
    const T_flux = normalize01(relVol);

    const raw = C_struct.map((c, i) => {
      const t = T_flux[i];
      if (c == null || t == null) return null;
      return c - beta * t;
    });

    const clipped = raw.map((v) => {
      if (v == null || !isFinite(v)) return 0;
      return Math.min(1, Math.max(0, v));
    });

    const ic0_100 = clipped.map((v) => v * 100);
    return ema(ic0_100, smoothLen);
  }

  // ----------------- ICD_BTC – INDICE COEZIV DIRECȚIONAL -----------------
  // Accent pe direcția trendului: penalizează în special mișcările contra-trend cu volatilitate mare.

  function calcIndiceCoezivDirectional(candles) {
    if (!candles || candles.length === 0) return [];

    const closes = candles.map((c) => c.close);

    const shortLen = 20;
    const longLen = 60;
    const atrLen = 14;
    const smoothLen = 10;
    const betaDir = 0.8;

    const emaShort = ema(closes, shortLen);
    const emaLong = ema(closes, longLen);

    // semn de trend (1 = bull, -1 = bear, 0 = flat)
    const trendSign = emaShort.map((es, i) => {
      const el = emaLong[i];
      if (es == null || el == null) return 0;
      const diff = es - el;
      if (!isFinite(diff) || Math.abs(diff) < 1e-8) return 0;
      return diff > 0 ? 1 : -1;
    });

    // randamente zilnice
    const returns = closes.map((c, i) => {
      if (i === 0) return 0;
      const p = closes[i - 1];
      if (p == null || !isFinite(p) || c == null || !isFinite(c)) return 0;
      return (c - p) / p;
    });

    const atr = computeATR(candles, atrLen);

    // flux direcțional: ATR penalizat doar când randamentul este împotriva trendului dominant
    const dirFlux = atr.map((a, i) => {
      if (!isFinite(a) || i === 0) return 0;
      const s = trendSign[i];
      const r = returns[i];
      if (s === 0 || !isFinite(r)) return 0;
      const aligned = Math.sign(r) === s;
      return aligned ? 0 : a;
    });

    // structură direcțională: panta dintre EMA short și EMA long, raportată la preț
    const structSlope = emaShort.map((es, i) => {
      const el = emaLong[i];
      const c = closes[i];
      if (es == null || el == null || c == null || !isFinite(c)) return null;
      const slope = es - el;
      return Math.abs(slope) / c;
    });

    const C_struct = normalize01(structSlope);
    const F_dir = normalize01(dirFlux);

    const raw = C_struct.map((c, i) => {
      const fd = F_dir[i];
      if (c == null || fd == null) return null;
      return c - betaDir * fd;
    });

    const clipped = raw.map((v) => {
      if (v == null || !isFinite(v)) return 0;
      return Math.max(0, Math.min(1, v));
    });

    const series0_100 = clipped.map((v) => v * 100);
    return ema(series0_100, smoothLen);
  }

  // ----------------- UI + CHART -----------------

  const btn = document.getElementById("loadBtn");
  const statusEl = document.getElementById("status");
  const lastEl = document.getElementById("lastVal");
  const ctx = document.getElementById("chart").getContext("2d");
  let chart = null;

  function regimeTag(value) {
    let label = "nedefinit";
    let cls = "tag-tranzitie";
    if (value >= 80) {
      label = "stabil (coeziv)";
      cls = "tag-stabil";
    } else if (value <= 20) {
      label = "critic";
      cls = "tag-critic";
    } else {
      label = "tranziție / reorganizare";
      cls = "tag-tranzitie";
    }
    return { label, cls };
  }

  function regimeTagHtml(value, prefixLabel) {
    if (value == null || !isFinite(value)) {
      return (
        prefixLabel + ': <strong>–</strong> <span class="tag tag-tranzitie">nedefinit</span>'
      );
    }
    const v = value.toFixed(2);
    const { label, cls } = regimeTag(value);
    return (
      prefixLabel +
      ': <strong>' +
      v +
      '</strong> <span class="tag ' +
      cls +
      '">' +
      label +
      "</span>"
    );
  }

  function updateChart(labels, icStruct, icDir) {
    if (chart) {
      chart.destroy();
    }
    chart = new Chart(ctx, {
      type: "line",
      data: {
        labels,
        datasets: [
          {
            label: "IC_BTC structural (0–100)",
            data: icStruct,
            borderWidth: 2,
            fill: false,
            tension: 0.25,
            pointRadius: 0,
          },
          {
            label: "ICD_BTC direcțional (0–100)",
            data: icDir,
            borderWidth: 2,
            fill: false,
            tension: 0.25,
            pointRadius: 0,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            ticks: {
              maxRotation: 50,
              minRotation: 30,
              color: "#9ca3af",
            },
            grid: {
              display: false,
            },
          },
          y: {
            min: 0,
            max: 100,
            ticks: {
              stepSize: 20,
              color: "#9ca3af",
            },
            grid: {
              color: "rgba(55,65,81,0.4)",
            },
          },
        },
        plugins: {
          legend: {
            labels: {
              color: "#e5e7eb",
            },
          },
          tooltip: {
            callbacks: {
              label: (ctx) =>
                ctx.dataset.label + ": " + ctx.parsed.y.toFixed(2),
            },
          },
        },
      },
    });
  }

  async function handleClick() {
    btn.disabled = true;
    statusEl.textContent = "Încarc btc_ohlc.json și calculez IC...";
    lastEl.innerHTML = 'Ultima valoare IC_BTC: <strong>–</strong>';

    try {
      const candles = await fetchBTC();
      if (!candles.length) {
        throw new Error("Nu am primit date BTC.");
      }

      const icStruct = calcIndiceCoezivStructural(candles);
      const icDir = calcIndiceCoezivDirectional(candles);

      const lastStruct = lastNonNull(icStruct);
      const lastDir = lastNonNull(icDir);

      const labels = candles.map((c) => {
        const d = new Date(c.timestamp);
        return d.toISOString().slice(0, 10);
      });

      updateChart(labels, icStruct, icDir);

      const htmlStruct = regimeTagHtml(
        lastStruct,
        "IC_BTC structural"
      );
      const htmlDir = regimeTagHtml(
        lastDir,
        "ICD_BTC direcțional"
      );

      lastEl.innerHTML = htmlStruct + "<br/>" + htmlDir;

      const lastDate = labels[labels.length - 1];
      statusEl.textContent =
        "Gata. Date până la " +
        lastDate +
        ". Structură și flux direcțional calculat pe 5 ani.";
    } catch (err) {
      console.error(err);
      statusEl.textContent = "Eroare: " + err.message;
    } finally {
      btn.disabled = false;
    }
  }

  btn.addEventListener("click", handleClick);
</script>
