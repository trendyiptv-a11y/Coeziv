<!DOCTYPE html>
<html lang="ro">
<head>
<meta charset="UTF-8">
<title>Indice Coeziv Bitcoin – LIVE & GRATUIT</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body {
    background: #020617;
    color: #e5e7eb;
    font-family: system-ui, sans-serif;
    margin: 0;
    padding: 1rem;
  }
  .card {
    background: #0b1120;
    padding: 1rem;
    margin-top: 0.9rem;
    border-radius: 12px;
  }
  button {
    width: 100%;
    padding: 0.75rem;
    border-radius: 999px;
    border: none;
    background: #2563eb;
    color: white;
    font-weight: 600;
    font-size: 0.95rem;
  }
  canvas { margin-top: 1rem; }
  .badge { padding: 0.1rem 0.5rem; border-radius: 999px; }
  .badge-green { background:#065f46; color:#a7f3d0; }
  .badge-yellow{ background:#78350f; color:#fde68a; }
  .badge-red   { background:#7f1d1d; color:#fecaca; }
</style>
</head>
<body>

<h2>Indice Coeziv Bitcoin – LIVE & GRATUIT</h2>
<p>Date live din Binance prin Bonsai API (gratuit, fără chei, fără proxy).</p>

<div class="card">
  <button id="loadBtn">Încarcă date BTC & calculează IC</button>
  <p id="status"></p>
</div>

<div class="card">
  <canvas id="chart" height="280"></canvas>
  <p id="lastVal"></p>
</div>

<script>
// ------------ UTILITARE ----------------
function ema(vals, len) {
  const k = 2/(len+1); 
  let e=null; 
  return vals.map(v=>{ if(e===null)e=v; else e=v*k+e*(1-k); return e; });
}
function rollingMean(a,l){
  return a.map((_,i)=> i<l?null:a.slice(i-l,i).reduce((s,x)=>s+x,0)/l);
}
function rollingStd(a,l){
  return a.map((_,i)=>{
    if(i<l)return null;
    let s=a.slice(i-l,i).filter(x=>x!=null);
    let m=s.reduce((x,y)=>x+y,0)/s.length;
    let v=s.reduce((x,y)=>x+(y-m)**2,0)/s.length;
    return Math.sqrt(v);
  });
}

// ------------ COMPUTE IC ---------------
function computeIC(close, volume) {
  const p={ lenTrend:200,lenShort:60,lenVol:30,lenATR:20,lenFlux:40,smooth:10,alpha:0.65,beta:0.35 };

  const open = close.map((c,i)=> i===0?c:close[i-1]);

  const emaLong  = ema(close,p.lenTrend);
  const emaShort = ema(close,p.lenShort);

  const trend = emaShort.map((v,i)=> Math.min(Math.abs(v-emaLong[i])/emaLong[i]/0.1,1));

  const ret = close.map((c,i)=> i===0?0:c-close[i-1]);
  const pos = ret.map(v=>v>0?v:0);
  const neg = ret.map(v=>v<0?-v:0);

  const dirPos=ema(pos,p.lenShort);
  const dirNeg=ema(neg,p.lenShort);
  const clean=dirPos.map((v,i)=>Math.abs((v/(v+dirNeg[i]+1e-9))-0.5)*2);

  const C_core = trend.map((v,i)=>0.7*v+0.3*clean[i]);

  const volMA = rollingMean(volume,p.lenVol);
  const volRel = volume.map((v,i)=>volMA[i]?Math.min(v/volMA[i],4)/4:null);

  const isUp = close.map((c,i)=>c>open[i]);
  const volUp = volume.map((v,i)=>isUp[i]?v:0);
  const volDn = volume.map((v,i)=>isUp[i]?0:v);
  const volUpMA = rollingMean(volUp,p.lenVol);
  const volDnMA = rollingMean(volDn,p.lenVol);
  const volQuality = volUpMA.map((v,i)=> v? v/(v+(volDnMA[i]||0)+1e-9):null);

  const ATR = ema(ret.map(v=>Math.abs(v)),p.lenATR);
  const atrRel = ATR.map((v,i)=>v/close[i]);
  const atrHealthy = atrRel.map(v=> 1-Math.abs(Math.min(v,0.16)/0.08-1) );

  const C_eco = volRel.map((v,i)=>v&&volQuality[i]&&atrHealthy[i]
      ?0.4*v+0.4*volQuality[i]+0.2*atrHealthy[i]:null);

  const C_core_std=rollingStd(C_core,p.lenFlux);
  const C_eco_std=rollingStd(C_eco,p.lenFlux);
  const atr_std=rollingStd(atrRel,p.lenFlux);

  const flux = C_core_std.map((v,i)=> v&&C_eco_std[i]&&atr_std[i]
      ?Math.min((v+C_eco_std[i]+atr_std[i])/0.03,1):null);

  const C_struct = C_core.map((v,i)=> v&&C_eco[i]? p.alpha*v+(1-p.alpha)*C_eco[i]:null);

  const raw = C_struct.map((v,i)=> v&&flux[i]? v - p.beta*flux[i] : null);

  const clipped = raw.map(v=> v==null?null:Math.max(0,Math.min(1,v)));
  return ema(clipped.map(v=>v*100),p.smooth);
}

// --------- FETCH STATIC din btc_ohlc.json ---------
async function fetchBTC() {
  const res = await fetch("btc_ohlc.json"); // fișierul din același folder
  if (!res.ok) {
    throw new Error("Nu pot încărca btc_ohlc.json (" + res.status + ")");
  }

  const data = await res.json();
  if (!Array.isArray(data)) {
    throw new Error("Format invalid în btc_ohlc.json");
  }

  // data = [{timestamp, open, high, low, close, volume}, ...]
  return data;
}

// ---------------- UI ----------------
const btn=document.getElementById("loadBtn");
const status=document.getElementById("status");
const last=document.getElementById("lastVal");
const ctx=document.getElementById("chart").getContext("2d");
let chart=null;

btn.onclick = async ()=>{
  btn.disabled=true;
  status.textContent="Încarc date BTC...";
  last.textContent="";

  try{
    const raw = await fetchBTC();
    const close = raw.map(x=>x.close);
    const vol   = raw.map(x=>x.volume);
    const dates = raw.map(x=> new Date(x.timestamp).toISOString().slice(0,10));

    status.textContent="Calculez indicele...";
    const ic = computeIC(close,vol);

    if(chart) chart.destroy();
    chart=new Chart(ctx,{
      type:"line",
      data:{
        labels:dates,
        datasets:[{
          data:ic,
          label:"IC_BTC (0–100)",
          borderColor:"#f8fafc",
          borderWidth:1.6,
          pointRadius:0,
          tension:0.15
        }]
      },
      options:{
        scales:{
          y:{min:0,max:100}
        }
      }
    });

    const lastVal = ic.at(-1).toFixed(2);
    let badge="";
    if(lastVal>=80) badge='<span class="badge badge-green">fază coezivă</span>';
    else if(lastVal<=20) badge='<span class="badge badge-red">critic</span>';
    else badge='<span class="badge badge-yellow">tranziție</span>';

    last.innerHTML = `Ultima valoare IC_BTC: <strong>${lastVal}</strong> ${badge}`;
    status.textContent="Gata.";

  }catch(e){
    status.textContent="Eroare: "+e.message;
  }finally{
    btn.disabled=false;
  }
};
</script>

</body>
</html>
