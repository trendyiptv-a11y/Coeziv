<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8" />
  <title>Indice Coeziv Bitcoin – IC_BTC</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="Indice Coeziv Bitcoin – structură, direcționalitate și cicluri ale trendului BTC, construit pe istoric BTCUSDT 1D (~14 ani). Model conceptual, nu recomandare financiară."
  />

  <!-- Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
    rel="stylesheet"
  />

  <!-- Chart.js + Time adapter -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.0/dist/chartjs-adapter-luxon.umd.min.js"></script>

  <style>
    :root {
      --bg-main: #020617;
      --bg-card: #020617;
      --bg-card-soft: #020617;
      --bg-card-strong: #0b1120;
      --border-subtle: rgba(148, 163, 184, 0.25);
      --border-strong: rgba(148, 163, 184, 0.5);
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.25);
      --accent-strong: #6366f1;
      --text: #e5e7eb;
      --text-soft: #9ca3af;
      --text-strong: #f9fafb;
      --danger: #f97373;
      --danger-soft: rgba(248, 113, 113, 0.22);
      --warn: #facc15;
      --warn-soft: rgba(250, 204, 21, 0.18);
      --radius-card: 18px;
      --radius-soft: 999px;
      --shadow-soft: 0 22px 48px rgba(15, 23, 42, 0.9);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at top, rgba(56, 189, 248, 0.12), transparent 55%),
        radial-gradient(circle at 20% 80%, rgba(129, 140, 248, 0.17), transparent 60%),
        #020617;
      color: var(--text);
      -webkit-font-smoothing: antialiased;
    }

    main {
      max-width: 1120px;
      margin: 0 auto;
      padding: 20px 14px 32px;
    }

    @media (min-width: 768px) {
      main {
        padding: 26px 18px 40px;
      }
    }

    header.page-header {
      margin-bottom: 18px;
    }

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.45);
      text-decoration: none;
      color: var(--text-soft);
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      margin-bottom: 10px;
      backdrop-filter: blur(10px);
      background: radial-gradient(circle at top left, rgba(148, 163, 184, 0.17), rgba(15, 23, 42, 0.9));
    }

    .back-link span.icon {
      font-size: 0.9rem;
      transform: translateY(-0.5px);
    }

    header.page-header h1 {
      margin: 0 0 4px;
      font-size: 1.52rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--text-strong);
    }

    header.page-header p {
      margin: 0;
      max-width: 640px;
      font-size: 0.92rem;
      color: var(--text-soft);
      line-height: 1.5;
    }

    .pill-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 9px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      font-size: 0.78rem;
      background: radial-gradient(circle at top left, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.9));
      color: var(--text-soft);
    }

    .pill-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent);
    }

    .pill-struct .pill-dot {
      background: #6366f1;
    }
    .pill-dir .pill-dot {
      background: #f97316;
    }
    .pill-flux .pill-dot {
      background: #22c55e;
    }
    .pill-cycle .pill-dot {
      background: #eab308;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 1.4fr) minmax(0, 1fr);
      gap: 14px;
      margin-top: 14px;
    }

    @media (max-width: 900px) {
      .layout {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .card {
      border-radius: var(--radius-card);
      background:
        radial-gradient(circle at top left, rgba(56, 189, 248, 0.16), transparent 55%),
        radial-gradient(circle at bottom right, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.98));
      border: 1px solid rgba(148, 163, 184, 0.3);
      padding: 16px 14px 15px;
      box-shadow: var(--shadow-soft);
    }

    .card-soft {
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.08), transparent 42%),
        var(--bg-card-soft);
    }

    @media (min-width: 768px) {
      .card {
        padding: 18px 18px 16px;
      }
    }

    .card-header {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      justify-content: space-between;
      gap: 8px 12px;
      margin-bottom: 10px;
    }

    .card-title {
      font-size: 1.02rem;
      font-weight: 600;
    }

    .card-subtitle {
      font-size: 0.84rem;
      color: var(--text-soft);
    }

    .meta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 12px;
      font-size: 0.8rem;
      color: var(--text-soft);
    }

    .meta-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.9);
    }

    .meta-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #4ade80;
    }

    .btn-primary {
      padding: 7px 13px;
      border-radius: 999px;
      border: none;
      font-size: 0.82rem;
      font-weight: 500;
      background: linear-gradient(135deg, #0ea5e9, #6366f1);
      color: white;
      cursor: pointer;
      box-shadow: 0 14px 32px rgba(37, 99, 235, 0.66);
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .btn-primary:disabled {
      opacity: 0.6;
      cursor: default;
      box-shadow: none;
    }

    .status-line {
      margin: 6px 0 0;
      font-size: 0.8rem;
      color: var(--text-soft);
    }

    .status-line strong {
      color: var(--text);
    }

    .status-error {
      color: #fecaca;
    }

    .status-error strong {
      color: #fecaca;
    }

    .status-ok strong {
      color: #bbf7d0;
    }

    .pill-regime {
      margin-top: 10px;
      padding: 10px 11px;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      background: radial-gradient(circle at top left, rgba(251, 191, 36, 0.12), rgba(15, 23, 42, 0.98));
      font-size: 0.8rem;
      color: var(--text-soft);
      display: none;
    }

    .pill-regime--warning {
      border-color: rgba(250, 204, 21, 0.7);
      background: radial-gradient(circle at top left, var(--warn-soft), rgba(15, 23, 42, 0.98));
    }

    .pill-regime--danger {
      border-color: rgba(248, 113, 113, 0.85);
      background: radial-gradient(circle at top left, var(--danger-soft), rgba(15, 23, 42, 0.98));
    }

    .pill-regime-title {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
      font-weight: 500;
      color: var(--text);
    }

    .pill-regime-title .badge-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #facc15;
    }

    .pill-regime-text {
      font-size: 0.8rem;
      line-height: 1.5;
    }

    .range-row {
      margin-top: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    .range-label {
      font-size: 0.8rem;
      color: var(--text-soft);
      margin-right: 4px;
    }

    .btn-range {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      background: rgba(15, 23, 42, 0.9);
      padding: 4px 9px;
      font-size: 0.78rem;
      color: var(--text-soft);
      cursor: pointer;
      transition: all 0.15s ease-out;
    }

    .btn-range:hover {
      border-color: rgba(148, 163, 184, 0.9);
      color: #e5e7eb;
      box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.9);
    }

    .btn-range.active {
      background: linear-gradient(135deg, #0ea5e9, #6366f1);
      color: white;
      border-color: transparent;
      box-shadow: 0 14px 28px rgba(37, 99, 235, 0.55);
      transform: translateY(-1px);
    }

    .chart-wrapper {
      position: relative;
      width: 100%;
      height: 280px;
      margin-top: 12px;
    }

    @media (min-width: 900px) {
      .chart-wrapper {
        height: 320px;
      }
    }

    canvas {
      border-radius: 16px;
    }

    .metrics-row {
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    @media (max-width: 640px) {
      .metrics-row {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .metric-card {
      padding: 10px 11px;
      border-radius: 14px;
      background: linear-gradient(
        135deg,
        rgba(15, 23, 42, 0.98),
        rgba(15, 23, 42, 0.94)
      );
      border: 1px solid rgba(148, 163, 184, 0.35);
    }

    .metric-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
    }

    .metric-name {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--text-soft);
    }

    .metric-value {
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--text-strong);
    }

    .metric-caption {
      font-size: 0.8rem;
      color: var(--text-soft);
      margin-top: 3px;
    }

    .badge {
      padding: 3px 7px;
      border-radius: 999px;
      font-size: 0.74rem;
      border: 1px solid rgba(148, 163, 184, 0.6);
      background: rgba(15, 23, 42, 0.9);
    }

    .badge--bull {
      border-color: rgba(74, 222, 128, 0.8);
      background: rgba(22, 163, 74, 0.22);
      color: #bbf7d0;
    }

    .badge--bear {
      border-color: rgba(248, 113, 113, 0.8);
      background: rgba(239, 68, 68, 0.18);
      color: #fecaca;
    }

    .badge--neutral {
      border-color: rgba(148, 163, 184, 0.8);
      background: rgba(15, 23, 42, 0.9);
      color: #e5e7eb;
    }

    .small-muted {
      margin-top: 8px;
      font-size: 0.78rem;
      color: var(--text-soft);
      line-height: 1.5;
    }

    footer {
      margin-top: 18px;
      font-size: 0.78rem;
      color: var(--text-soft);
      line-height: 1.5;
    }

    footer strong {
      color: var(--text);
    }

    footer a {
      color: #7dd3fc;
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <main>
    <header class="page-header">
      <a href="index.html" class="back-link">
        <span class="icon">←</span>
        <span>Înapoi la landing IC_BTC</span>
      </a>

      <h1>Indice Coeziv Bitcoin – IC_BTC</h1>
      <p>
        Structură, direcționalitate, flux și ciclu pentru BTC (BTCUSDT 1D), construite prin modelul Coeziv.
        Indicii sunt scalați 0–100 și ajută la înțelegerea poziției în trend, nu la predicția exactă a prețului.
      </p>

      <div class="pill-row">
        <div class="pill pill-struct">
          <span class="pill-dot"></span>
          <span>IC_BTC structural – coeziunea trendului</span>
        </div>
        <div class="pill pill-dir">
          <span class="pill-dot"></span>
          <span>ICD_BTC direcțional – bias bull/bear</span>
        </div>
        <div class="pill pill-flux">
          <span class="pill-dot"></span>
          <span>ICF_BTC flux – stres / calm</span>
        </div>
        <div class="pill pill-cycle">
          <span class="pill-dot"></span>
          <span>ICC_BTC ciclu – fază de ciclu</span>
        </div>
      </div>
    </header>

    <section class="layout">
      <!-- Control / status -->
      <section class="card card-soft">
        <div class="card-header">
          <div>
            <div class="card-title">Încărcare date & model coeziv</div>
            <div class="card-subtitle">
              Date BTCUSDT 1D din <code>btc_ohlc.json</code> + indicii IC_BTC, ICD_BTC, flux și ciclu din
              <code>data/ic_btc_series.json</code>.
            </div>
          </div>
          <button id="btnLoad" class="btn-primary">
            <span>Încarcă / recalculează</span>
          </button>
        </div>

        <div class="meta-row">
          <span class="meta-pill">
            <span class="meta-dot"></span>
            <span>Model Coeziv calculat în Python</span>
          </span>
          <span class="meta-pill">
            <span class="meta-dot" style="background:#38bdf8;"></span>
            <span>Randare & interactivitate în browser</span>
          </span>
        </div>

        <p id="status" class="status-line">
          <strong>Status:</strong> așteaptă încărcarea datelor BTC.
        </p>

        <div id="statusDate" class="status-line" style="margin-top: 4px;">
          Date disponibile până la: <strong id="lastDateText">–</strong>.
        </div>

        <!-- Regim general -->
        <div id="regimeBox" class="pill-regime" style="display: none;">
          <div class="pill-regime-title">
            <span class="badge-dot"></span>
            <span id="regimeTitle">Regim general</span>
          </div>
          <div id="regimeText" class="pill-regime-text">
            –
          </div>
        </div>

        <!-- Range controls -->
        <div class="range-row">
          <span class="range-label">Interval grafic:</span>
          <button class="btn-range active" data-range="all">Tot istoricul</button>
          <button class="btn-range" data-range="5y">Ultimii 5 ani</button>
          <button class="btn-range" data-range="1y">Ultimul an</button>
          <button class="btn-range" data-range="260d">Ultimele 260 zile (model)</button>
          <button class="btn-range" data-range="90d">Ultimele 90 zile</button>
        </div>
        <p class="small-muted">
          Intervalul „Ultimele 260 zile (model)” folosește exact fereastra internă a modelului Coeziv Bitcoin
          și este aliniat cu snapshot-ul live din pagina principală.
        </p>

        <p class="small-muted">
          Indicii sunt normalizați în intervalul 0–100 și neteziți moderat (EMA) pentru o structură
          vizuală mai clară, fără a altera trendul de fond.
        </p>
      </section>

      <!-- STRUCTURAL + DIRECTIONAL -->
      <section class="card">
        <div class="card-header">
          <div>
            <div class="card-title">Indice structural &amp; direcțional (0–100)</div>
            <div class="card-subtitle">IC_BTC structural vs ICD_BTC direcțional</div>
          </div>
        </div>

        <div class="chart-wrapper">
          <canvas id="chartStructDir"></canvas>
        </div>

        <div class="metrics-row">
          <article class="metric-card">
            <div class="metric-header">
              <span class="metric-name">IC_BTC structural</span>
              <span id="badgeStruct" class="badge badge--neutral">–</span>
            </div>
            <div class="metric-value" id="valStruct">–</div>
            <div class="metric-caption">
              Regim structural (trend vs flux total, volatilitate relativă).
            </div>
          </article>

          <article class="metric-card">
            <div class="metric-header">
              <span class="metric-name">ICD_BTC direcțional</span>
              <span id="badgeDir" class="badge badge--neutral">–</span>
            </div>
            <div class="metric-value" id="valDir">–</div>
            <div class="metric-caption">
              Bias bull / bear agregat (aliniere mișcări cu direcția de fond).
            </div>
          </article>

          <article class="metric-card">
            <div class="metric-header">
              <span class="metric-name">ICF_BTC flux</span>
              <span id="badgeFlux" class="badge badge--neutral">–</span>
            </div>
            <div class="metric-value" id="valFlux">–</div>
            <div class="metric-caption">
              Flux & tensiune: cât de stresată sau calmă e piața.
            </div>
          </article>

          <article class="metric-card">
            <div class="metric-header">
              <span class="metric-name">ICC_BTC ciclu</span>
              <span id="badgeCycle" class="badge badge--neutral">–</span>
            </div>
            <div class="metric-value" id="valCycle">–</div>
            <div class="metric-caption">
              Poziționare în ciclu: faze de bază, expansiune, distribuție, reset.
            </div>
          </article>
        </div>
      </section>
    </section>

    <!-- FLUX + CICLU -->
    <section class="card" style="margin-top: 14px;">
      <div class="card-header">
        <div>
          <div class="card-title">Flux &amp; ciclu (0–100)</div>
          <div class="card-subtitle">ICF_BTC flux vs ICC_BTC ciclu – vizualizare combinată</div>
        </div>
      </div>
      <div class="chart-wrapper">
        <canvas id="chartFluxCycle"></canvas>
      </div>
      <p class="small-muted">
        Fluxul (ICF_BTC) surprinde episoadele de stres / calm, iar ICC_BTC urmărește fazele interne de ciclu
        (acumulare, expansiune, distribuție, reset). Zonele extreme sunt rare și tind să coincidă cu
        momentele cheie de ciclu.
      </p>
    </section>

    <footer>
      <p>
        <strong>Notă:</strong> IC_BTC, ICD_BTC, ICF_BTC și ICC_BTC sunt indici conceptuali ai Modelului Coeziv,
        construiți pentru a descrie structura și dinamica trendului BTC. Nu reprezintă recomandare de investiții
        și nu garantează direcția viitoare a prețului. Folosește-i doar ca instrument de context structural,
        împreună cu propriul management de risc.
      </p>
    </footer>
  </main>

  <script>
    const { DateTime } = luxon;

    // ----------------- STATE GLOBAL -----------------
    let fullCandles = [];
    let seriesStruct = [];
    let seriesDir = [];
    let seriesFlux = [];
    let seriesCycle = [];
    let marketRegimes = [];

    let chartStructDir = null;
    let chartFluxCycle = null;

    const btnLoad = document.getElementById("btnLoad");
    const statusEl = document.getElementById("status");
    const statusDateEl = document.getElementById("statusDate");
    const lastDateTextEl = document.getElementById("lastDateText");

    const rangeButtons = Array.from(document.querySelectorAll(".btn-range"));

    const valStructEl = document.getElementById("valStruct");
    const valDirEl = document.getElementById("valDir");
    const valFluxEl = document.getElementById("valFlux");
    const valCycleEl = document.getElementById("valCycle");

    const badgeStructEl = document.getElementById("badgeStruct");
    const badgeDirEl = document.getElementById("badgeDir");
    const badgeFluxEl = document.getElementById("badgeFlux");
    const badgeCycleEl = document.getElementById("badgeCycle");

    const regimeBoxEl = document.getElementById("regimeBox");
    const regimeTitleEl = document.getElementById("regimeTitle");
    const regimeTextEl = document.getElementById("regimeText");

    rangeButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        if (!seriesStruct.length) return;
        rangeButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        applyRange(btn.dataset.range || "all");
      });
    });

    btnLoad.addEventListener("click", () => {
      loadAndCompute();
    });

    // ----------------- LOAD & MODEL (PYTHON) -----------------
    async function loadAndCompute() {
      btnLoad.disabled = true;
      statusEl.innerHTML =
        '<strong>Status:</strong> încarc datele BTC & indicii coezivi din model...';
      statusEl.classList.remove("status-error", "status-ok");

      try {
        const [resOhlc, resIc] = await Promise.all([
          fetch("btc_ohlc.json", { cache: "no-store" }),
          fetch("data/ic_btc_series.json", { cache: "no-store" })
        ]);

        if (!resOhlc.ok) {
          throw new Error("Nu pot încărca btc_ohlc.json (" + resOhlc.status + ").");
        }
        if (!resIc.ok) {
          throw new Error("Nu pot încărca data/ic_btc_series.json (" + resIc.status + ").");
        }

        const rawOhlc = await resOhlc.json();
        if (!Array.isArray(rawOhlc)) {
          throw new Error("Format invalid în btc_ohlc.json.");
        }

        const icJson = await resIc.json();
        const icSeries = Array.isArray(icJson.series) ? icJson.series : null;
        if (!icSeries || !icSeries.length) {
          throw new Error("data/ic_btc_series.json nu conține seria IC_BTC.");
        }

        // Construim fullCandles pentru preț (dacă e nevoie în alte grafice)
        fullCandles = rawOhlc
          .map((c) => {
            const rawT =
              c.timestamp ??
              c.time ??
              c.t ??
              c.date ??
              c.dt ??
              null;
            const t = rawT != null ? new Date(rawT) : null;
            return {
              t,
              open: Number(c.open),
              high: Number(c.high),
              low: Number(c.low),
              close: Number(c.close),
              volume: Number(c.volume ?? 0),
            };
          })
          .filter(
            (c) =>
              c.t instanceof Date &&
              !Number.isNaN(c.t) &&
              Number.isFinite(c.close)
          )
          .sort((a, b) => a.t - b.t);

        if (!fullCandles.length) {
          throw new Error("Nu am găsit date valide în btc_ohlc.json.");
        }

        // Umplem seriile direct din modelul Python (fără computeIndices în browser)
        seriesStruct = icSeries
          .map((p) => ({
            x: new Date(p.t),
            y: Number(p.ic_struct),
          }))
          .filter(
            (p) =>
              p.x instanceof Date &&
              !Number.isNaN(p.x) &&
              Number.isFinite(p.y)
          );

        seriesDir = icSeries
          .map((p) => ({
            x: new Date(p.t),
            y: Number(p.ic_dir),
          }))
          .filter(
            (p) =>
              p.x instanceof Date &&
              !Number.isNaN(p.x) &&
              Number.isFinite(p.y)
          );

        seriesFlux = icSeries
          .map((p) => ({
            x: new Date(p.t),
            y: Number(p.ic_flux),
          }))
          .filter(
            (p) =>
              p.x instanceof Date &&
              !Number.isNaN(p.x) &&
              Number.isFinite(p.y)
          );

        seriesCycle = icSeries
          .map((p) => ({
            x: new Date(p.t),
            y: Number(p.ic_cycle),
          }))
          .filter(
            (p) =>
              p.x instanceof Date &&
              !Number.isNaN(p.x) &&
              Number.isFinite(p.y)
          );

        if (!seriesStruct.length || !seriesDir.length) {
          throw new Error("Seriile IC_BTC din model sunt goale sau invalide.");
        }

        // Regimuri bull/bear – folosim în continuare logica existentă pe baza IC/ICD
        marketRegimes = detectRegimesFromIC(seriesStruct, seriesDir);

        // Ultima dată – din seria IC (modelul oficial)
        const lastPoint = icSeries[icSeries.length - 1];
        const lastDate = new Date(lastPoint.t);
        const formatter = new Intl.DateTimeFormat("ro-RO", { dateStyle: "medium" });
        lastDateTextEl.textContent = formatter.format(lastDate);
        statusDateEl.innerHTML =
          'Date disponibile până la: <strong>' +
          lastDateTextEl.textContent +
          "</strong>.";

        statusEl.innerHTML =
          "<strong>Status:</strong> gata. Indicii IC_BTC & ICD_BTC sunt încărcați direct din modelul coeziv (Python) pe întreaga serie.";
        statusEl.classList.add("status-ok");
        statusEl.classList.remove("status-error");

        if (!chartStructDir || !chartFluxCycle) {
          initCharts();
        } else {
          updateChartsData();
        }

        const activeRangeBtn =
          document.querySelector(".btn-range.active") || rangeButtons[0];
        applyRange(activeRangeBtn.dataset.range || "all");

        updateMetricsUI();
      } catch (err) {
        console.error(err);
        statusEl.innerHTML =
          "<strong>Status:</strong> eroare la încărcare – " + err.message;
        statusEl.classList.add("status-error");
        statusEl.classList.remove("status-ok");
      } finally {
        btnLoad.disabled = false;
      }
    }

    // ----------------- CHARTS -----------------
    function initCharts() {
      const ctxStructDir = document.getElementById("chartStructDir").getContext("2d");
      const ctxFluxCycle = document.getElementById("chartFluxCycle").getContext("2d");

      chartStructDir = new Chart(ctxStructDir, {
        type: "line",
        data: {
          datasets: [
            {
              label: "IC_BTC structural",
              data: [],
              borderWidth: 2,
              tension: 0.2,
              pointRadius: 0,
              borderColor: "#38bdf8",
              backgroundColor: "rgba(56,189,248,0.22)",
            },
            {
              label: "ICD_BTC direcțional",
              data: [],
              borderWidth: 1.6,
              tension: 0.2,
              pointRadius: 0,
              borderDash: [5, 4],
              borderColor: "#f97316",
              backgroundColor: "rgba(248,171,104,0.18)",
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: "index",
            intersect: false,
          },
          plugins: {
            legend: {
              labels: {
                color: "#e5e7eb",
                font: { size: 11 },
              },
            },
            tooltip: {
              callbacks: {
                title(items) {
                  if (!items.length) return "";
                  const d = items[0].raw.x;
                  return DateTime.fromJSDate(d).toFormat("dd LLL yyyy");
                },
                label(ctx) {
                  const label = ctx.dataset.label || "";
                  const v = ctx.raw.y;
                  if (v == null || Number.isNaN(v)) return label;
                  return label + ": " + v.toFixed(2);
                },
              },
            },
            regimeBackground: {}, // plugin-ul folosește marketRegimes global
          },
          scales: {
            x: {
              type: "time",
              time: {
                unit: "year",
              },
              grid: {
                color: "rgba(30,64,175,0.35)",
              },
              ticks: {
                color: "#9ca3af",
                maxRotation: 0,
              },
            },
            y: {
              min: 0,
              max: 100,
              grid: {
                color: "rgba(30,64,175,0.3)",
              },
              ticks: {
                color: "#9ca3af",
                stepSize: 20,
              },
            },
          },
        },
        plugins: [
          {
            id: "regimeBackground",
            beforeDraw(chart, args, opts) {
              const ctx = chart.ctx;
              const xScale = chart.scales.x;
              const yScale = chart.scales.y;
              if (!marketRegimes.length || !xScale || !yScale) return;

              const topY = yScale.getPixelForValue(yScale.max);
              const bottomY = yScale.getPixelForValue(yScale.min);

              marketRegimes.forEach((seg) => {
                const xStart = xScale.getPixelForValue(seg.startTs);
                const xEnd = xScale.getPixelForValue(seg.endTs);
                if (!Number.isFinite(xStart) || !Number.isFinite(xEnd)) return;

                const width = xEnd - xStart;
                if (width <= 0) return;

                let color = "rgba(34,197,94,0.06)";
                if (seg.type === "bear") {
                  color = "rgba(248,113,113,0.07)";
                }

                ctx.save();
                ctx.fillStyle = color;
                ctx.fillRect(xStart, topY, width, bottomY - topY);
                ctx.restore();
              });
            },
          },
        ],
      });

      chartFluxCycle = new Chart(ctxFluxCycle, {
        type: "line",
        data: {
          datasets: [
            {
              label: "ICF_BTC flux",
              data: [],
              borderWidth: 1.8,
              tension: 0.2,
              pointRadius: 0,
              borderColor: "#22c55e",
              backgroundColor: "rgba(34,197,94,0.22)",
            },
            {
              label: "ICC_BTC ciclu",
              data: [],
              borderWidth: 1.5,
              tension: 0.2,
              pointRadius: 0,
              borderDash: [6, 4],
              borderColor: "#eab308",
              backgroundColor: "rgba(234,179,8,0.20)",
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: "index",
            intersect: false,
          },
          plugins: {
            legend: {
              labels: {
                color: "#e5e7eb",
                font: { size: 11 },
              },
            },
            tooltip: {
              callbacks: {
                title(items) {
                  if (!items.length) return "";
                  const d = items[0].raw.x;
                  return DateTime.fromJSDate(d).toFormat("dd LLL yyyy");
                },
                label(ctx) {
                  const label = ctx.dataset.label || "";
                  const v = ctx.raw.y;
                  if (v == null || Number.isNaN(v)) return label;
                  return label + ": " + v.toFixed(2);
                },
              },
            },
          },
          scales: {
            x: {
              type: "time",
              time: {
                unit: "year",
              },
              grid: {
                color: "rgba(30,64,175,0.35)",
              },
              ticks: {
                color: "#9ca3af",
                maxRotation: 0,
              },
            },
            y: {
              min: 0,
              max: 100,
              grid: {
                color: "rgba(30,64,175,0.3)",
              },
              ticks: {
                color: "#9ca3af",
                stepSize: 20,
              },
            },
          },
        },
      });
    }

    function updateChartsData() {
      chartStructDir.data.datasets[0].data = seriesStruct;
      chartStructDir.data.datasets[1].data = seriesDir;
      chartFluxCycle.data.datasets[0].data = seriesFlux;
      chartFluxCycle.data.datasets[1].data = seriesCycle;
      chartStructDir.update();
      chartFluxCycle.update();
    }

    function applyRange(rangeKey) {
      if (!seriesStruct.length) return;

      const lastX = seriesStruct[seriesStruct.length - 1].x;
      let fromX = seriesStruct[0].x;

      const dayMs = 24 * 60 * 60 * 1000;

      switch (rangeKey) {
        case "90d":
          fromX = lastX - 90 * dayMs;
          break;
        case "260d":
          fromX = lastX - 260 * dayMs;
          break;
        case "1y":
          fromX = lastX - 365 * dayMs;
          break;
        case "5y":
          fromX = lastX - 5 * 365 * dayMs;
          break;
        case "all":
        default:
          fromX = seriesStruct[0].x;
      }

      const filterRange = (points) =>
        points.filter((p) => p.x >= fromX && p.x <= lastX);

      const sStruct = filterRange(seriesStruct);
      const sDir = filterRange(seriesDir);
      const sFlux = filterRange(seriesFlux);
      const sCycle = filterRange(seriesCycle);

      chartStructDir.data.datasets[0].data = sStruct;
      chartStructDir.data.datasets[1].data = sDir;
      chartFluxCycle.data.datasets[0].data = sFlux;
      chartFluxCycle.data.datasets[1].data = sCycle;

      chartStructDir.options.scales.x.min = fromX;
      chartStructDir.options.scales.x.max = lastX;
      chartFluxCycle.options.scales.x.min = fromX;
      chartFluxCycle.options.scales.x.max = lastX;

      chartStructDir.update();
      chartFluxCycle.update();
    }

    // ----------------- UI METRICS + REGIM -----------------
    function classifyScore(kind, value) {
      if (value == null || Number.isNaN(value)) {
        return { label: "–", cls: "badge--neutral" };
      }

      if (kind === "flux") {
        if (value > 70) return { label: "stres ridicat", cls: "badge--bear" };
        if (value < 30) return { label: "flux calm", cls: "badge--bull" };
        return { label: "flux mixt", cls: "badge--neutral" };
      }

      if (kind === "cycle") {
        if (value > 70) return { label: "fază avansată", cls: "badge--bear" };
        if (value < 30) return { label: "fază timpurie", cls: "badge--bull" };
        return { label: "fază intermediară", cls: "badge--neutral" };
      }

      // structural / direcțional
      if (value > 60) return { label: "puternic", cls: "badge--bull" };
      if (value < 40) return { label: "slab", cls: "badge--bear" };
      return { label: "mediu", cls: "badge--neutral" };
    }

    function updateMetricsUI() {
      if (!seriesStruct.length || !seriesDir.length || !seriesFlux.length || !seriesCycle.length) {
        valStructEl.textContent = "–";
        valDirEl.textContent = "–";
        valFluxEl.textContent = "–";
        valCycleEl.textContent = "–";
        return;
      }

      const lastStruct = seriesStruct[seriesStruct.length - 1].y;
      const lastDir = seriesDir[seriesDir.length - 1].y;
      const lastFlux = seriesFlux[seriesFlux.length - 1].y;
      const lastCycle = seriesCycle[seriesCycle.length - 1].y;

      valStructEl.textContent = Number.isFinite(lastStruct) ? lastStruct.toFixed(2) : "–";
      valDirEl.textContent = Number.isFinite(lastDir) ? lastDir.toFixed(2) : "–";
      valFluxEl.textContent = Number.isFinite(lastFlux) ? lastFlux.toFixed(2) : "–";
      valCycleEl.textContent = Number.isFinite(lastCycle) ? lastCycle.toFixed(2) : "–";

      const clsStruct = classifyScore("struct", lastStruct);
      const clsDir = classifyScore("dir", lastDir);
      const clsFlux = classifyScore("flux", lastFlux);
      const clsCycle = classifyScore("cycle", lastCycle);

      badgeStructEl.textContent = clsStruct.label;
      badgeDirEl.textContent = clsDir.label;
      badgeFluxEl.textContent = clsFlux.label;
      badgeCycleEl.textContent = clsCycle.label;

      [badgeStructEl, badgeDirEl, badgeFluxEl, badgeCycleEl].forEach((el) => {
        el.classList.remove("badge--bull", "badge--bear", "badge--neutral");
      });
      badgeStructEl.classList.add(clsStruct.cls);
      badgeDirEl.classList.add(clsDir.cls);
      badgeFluxEl.classList.add(clsFlux.cls);
      badgeCycleEl.classList.add(clsCycle.cls);

      // Regim general
      let regimeType = "transition";
      if (lastStruct >= 80 && lastDir >= 80 && lastFlux >= 60) {
        regimeType = "stable";
      } else if (lastStruct < 20 || lastDir < 20 || lastFlux < 30) {
        regimeType = "critical";
      }

      regimeBoxEl.style.display = "block";
      regimeBoxEl.classList.remove("pill-regime--warning", "pill-regime--danger");

      if (regimeType === "stable") {
        regimeTitleEl.textContent = "Regim coeziv stabil";
        regimeTextEl.textContent =
          "Structură coezivă, trend relativ consistent, flux controlat și stres moderat. Context de stabilitate structurală (nu înseamnă direcție garantată a prețului).";
      } else if (regimeType === "critical") {
        regimeBoxEl.classList.add("pill-regime--danger");
        regimeTitleEl.textContent = "Fază critică";
        regimeTextEl.textContent =
          "Stres ridicat în structură (IC_BTC sau ICD_BTC foarte tensionat). Episoade de volatilitate mare și structură fragilă.";
      } else {
        regimeBoxEl.classList.add("pill-regime--warning");
        regimeTitleEl.textContent = "Fază de tranziție / reorganizare";
        regimeTextEl.textContent =
          "Structură mixtă: trendul și fluxul se reorganizează. Poate fi începutul unei faze de consolidare, schimbare de regim sau realiniere a structurii.";
      }
    }

    // ----------------- DETECT REGIMURI (bull / bear) -----------------
    function detectRegimesFromIC(structSeries, dirSeries) {
      if (!structSeries.length || !dirSeries.length) return [];

      const n = Math.min(structSeries.length, dirSeries.length);
      const segments = [];
      const MIN_LEN = 20;

      function labelFor(structVal, dirVal) {
        if (structVal == null || dirVal == null) return "neutral";
        if (structVal >= 60 && dirVal >= 55) return "bull";
        if (structVal <= 40 && dirVal <= 45) return "bear";
        return "neutral";
      }

      let current = null;

      function closeSegment(endIdx) {
        if (!current) return;
        const length = endIdx - current.startIdx + 1;
        if (length >= MIN_LEN && (current.type === "bull" || current.type === "bear")) {
          const startPoint = structSeries[current.startIdx];
          const endPoint   = structSeries[endIdx];
          segments.push({
            type: current.type,
            startIdx: current.startIdx,
            endIdx,
            startTs: startPoint.x,
            endTs: endPoint.x,
            length
          });
        }
        current = null;
      }

      for (let i = 0; i < n; i++) {
        const s = structSeries[i]?.y;
        const d = dirSeries[i]?.y;
        const label = labelFor(s, d);

        if (!current) {
          if (label === "bull" || label === "bear") {
            current = { type: label, startIdx: i };
          }
        } else {
          if (label !== current.type) {
            closeSegment(i - 1);
            if (label === "bull" || label === "bear") {
              current = { type: label, startIdx: i };
            } else {
              current = null;
            }
          }
        }
      }

      if (current) {
        closeSegment(n - 1);
      }

      return segments;
    }
  </script>
</body>
</html>
